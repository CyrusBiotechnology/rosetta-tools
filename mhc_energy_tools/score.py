#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Performs basic epitope prediction for a sequence or set of sequences, to support pre- and post-processing of mhc_epitope energy optimized designs.
Provide sequence(s) and specify predictor and its parameters; the script generates either the total score (useful for testing) or a peptide-by-peptide report.
Currently supports prediction via
- matrix methods, with code particularly targeted to Propred matrices (as provided with the distribution),
- the NetMHCII executable, wrapping the invocation and processing the results
- precomputed epitope information stored in an sqlite database for efficient querying, as generated by db.py

@author: Chris Bailey-Kellogg, cbk@cs.dartmouth.edu; Brahm Yachnin, brahm.yachnin@rutgers.edu 
"""

import argparse, sys
from epilib.epitope_predictor_matrix import EpitopePredictorMatrix, Propred
from epilib.epitope_database import EpitopeDatabase
from epilib.netmhcII import NetMHCII
from epilib.sequence import Sequence, load_fa, load_pep, load_fsa, load_pdb

def setup_parser():
    """Creates an ArgumentParser and sets up all its arguments.
    returns: ArgumentParser"""
    parser = argparse.ArgumentParser(description="""Predicts epitopes for a sequence or set of sequences. 
Performs basic epitope prediction for a sequence or set of sequences, to support pre- and post-processing of mhc_epitope energy optimized designs.
Provide sequence(s) and specify predictor and its parameters; the script generates either the total score (useful for testing) or a peptide-by-peptide report.""", 
                                     formatter_class=argparse.RawDescriptionHelpFormatter,
                                     epilog="""Additional notes:
- Only uses one source for sequences, checking in order: command-line, specified input file, stdin
- Sequences can include '_' characters, treated as noncanonicals
- The "fasta-ish" header can end in "@pos" to start residue numbering there; default 1
- Pretty rudimentary handling of PDB files, padding missing residues with '_' and generally dealing only with the standard twenty 3-letter AA codes
- If no predictor specified, defaults to propred
- Allele sets include 'all' and 'test', specific to predictors, as well as two published lists that are supported by NetMHCII:
  + greenbaum11: www.ncbi.nlm.nih.gov/pubmed/21305276
  + paul15: www.ncbi.nlm.nih.gov/pubmed/25862607
- Looks for predictor matrix file in current directory as well as in $ROSETTA/main/database/scoring/score_terms/mhc_epitope.
- For "silent" treatment of noncanonicals, Matrix/Propred says no epitope; NetMHCII treats as 'X' and somehow scores anyway.""")
    # where to get the sequence(s), unless on command line
    source = parser.add_mutually_exclusive_group()
    source.add_argument('--fa', help="name of file with single sequence in fasta-ish format, '>' line optional")
    source.add_argument('--fsa', help="name of file with one or more sequences in fasta-ish format, each including '>' line")
    source.add_argument('--pdb', help='name of file with one or more sequences embedded in pdb format')
    source.add_argument('--pep', help="name of file with one sequence per line")
    # epitope predictor
    pred = parser.add_mutually_exclusive_group()
    pred.add_argument('--db', help='name of database from which to load epitope predictions')
    pred.add_argument('--matrix', help='generic epitope predictor matrix filename')
    pred.add_argument('--netmhcii', action='store_true', help='use netmhcII executable')
    pred.add_argument('--propred', action='store_true', help='use propred matrices')
    # epitope predictor alleles
    alleles = parser.add_mutually_exclusive_group()
    alleles.add_argument('--allele_set', help='name of predefined set of alleles', choices=['test', 'greenbaum11', 'paul15'])
    alleles.add_argument('--alleles', help='comma-separated list of allele names')
    # epitope predictor parameters
    parser.add_argument('--epi_thresh', help='epitope predictor threshold (default: %(default).2f)', type=float, default=5)
    parser.add_argument('--noncanon', help='how to treat letters other than the 20 canonical AAs (default: %(default)s)', choices=['error', 'silent', 'warn'])
    parser.add_argument('--netmhcii_score', help='type of score to compute (default %(default)s)', choices=['rank','absolute'], default='rank')
    # output
    parser.add_argument('--report', help='type of output report, just the _total_ score / details for epitope _hits_ / scores for _all_ peptides (default: %(default)s)', choices=['total','hits','full'], default='total')
    # sequence(s) on command-line
    parser.add_argument('seq', help='raw sequence as string', nargs='*')
    
    return parser

def main(args):
    """Sets up an epitope prediction run based on the parsed args.
    args: ArgumentParser"""
    
    # epitope predictor
    if args.matrix is not None:
        pred = EpitopePredictorMatrix.load(args.matrix)
    elif args.netmhcii:
        pred = NetMHCII(score_type=args.netmhcii_score[0])
    elif args.db is not None:
        pred = EpitopeDatabase.for_reading(args.db)
    else:
        pred = Propred.load()
    pred.threshold = args.epi_thresh
    
    # alleles
    if args.allele_set is not None:
        if args.allele_set not in pred.allele_sets: 
            raise Exception('alleleset '+args.allele_set+' not supported')
        pred.filter_alleles(pred.allele_sets[args.allele_set])
    elif args.alleles is not None:
        pred.filter_alleles(args.alleles.split(','))

    # Helper method to process a single Sequence. Also accesses variable "args" from the containing scope.
    def handle_seq(seq):
        epimap = pred.score_protein(seq.seq)
        if args.report=='total':
            print('*', seq.name, epimap.total_score())
        else: 
            print('*', seq.name)
            epimap.report(full=(args.report=='full'), thresh=args.epi_thresh, start=seq.start)   

    # Get sequences from whatever source is specified
    # Predict epitopes for each
    if len(args.seq)>0:
        for (i, seq) in enumerate(args.seq): handle_seq(Sequence(seq, name='seq'+str(i)))           
    elif args.fa is not None:
        handle_seq(load_fa(args.fa))
    elif args.fsa is not None:
        for seq in load_fsa(args.fsa): handle_seq(seq)
    elif args.pdb is not None:
        for seq in load_pdb(args.pdb): handle_seq(seq)
    elif args.pep is not None:
        for seq in load_pep(args.pep): handle_seq(seq)
    else:
        print('enter sequences:')
        i = 0
        for line in sys.stdin:
            handle_seq(Sequence(line.strip(), name='seq'+str(i)))
            i += 1

if __name__ == '__main__':
    parser = setup_parser()
    args = parser.parse_args()
    try:
        main(args)
    except Exception as e:
        print('ERROR', e)
        print()
        parser.print_usage()  