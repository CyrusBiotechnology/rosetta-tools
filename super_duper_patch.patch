diff --git a/src/apps/pilot/bcorreia/fold_from_loops.cc b/src/apps/pilot/bcorreia/fold_from_loops.cc
index 833c4e7..087433a 100644
--- a/src/apps/pilot/bcorreia/fold_from_loops.cc
+++ b/src/apps/pilot/bcorreia/fold_from_loops.cc
@@ -131,6 +131,7 @@
 #include <core/pose/util.hh>
 #include <core/scoring/Energies.hh>
 #include <protocols/relax/ClassicRelax.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -659,7 +660,7 @@ void new_pose_generator(core::pose::Pose & target_loops, core::pose::Pose & nat_
 	core::pose::Pose centroid_target_loops;
 
 
-	core::pose::switch_to_residue_type_set( target_loops , core::chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( target_loops , core::chemical::CENTROID );
 
 	core::chemical::ResidueTypeSet const & rsd_set( target_loops.residue(1).residue_type_set() );
 
@@ -905,7 +906,7 @@ main( int argc, char* argv [] )
 
 	extended_pose.fold_tree( f ); // apply the fold tree
 
-	core::pose::switch_to_residue_type_set( extended_pose, core::chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( extended_pose, core::chemical::CENTROID );
 
 
 
@@ -1131,7 +1132,7 @@ main( int argc, char* argv [] )
 		std::string outfilename = option[ out::prefix ]() + "_" + right_string_of(i,3,'0') + ".pdb.gz"; //building name
 
 
-		core::pose::switch_to_residue_type_set( fold_pose, chemical::FA_STANDARD ); //switching the pose for full atom
+		protocols::toolbox::switch_to_residue_type_set( fold_pose, chemical::FA_STANDARD ); //switching the pose for full atom
 
 
 		core::scoring::ScoreFunctionOP scorefxn_fa( ScoreFunctionFactory::create_score_function( STANDARD_WTS, SCORE12_PATCH ) );
diff --git a/src/apps/pilot/blivens/conserve_disulfides.cc b/src/apps/pilot/blivens/conserve_disulfides.cc
index 077433d..8f16f5b 100644
--- a/src/apps/pilot/blivens/conserve_disulfides.cc
+++ b/src/apps/pilot/blivens/conserve_disulfides.cc
@@ -65,6 +65,7 @@ using namespace core::conformation;
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 basic::Tracer TR( "pilot_apps.blivens.disulfide_handoff" );
 
@@ -110,7 +111,7 @@ int main( int argc, char * argv [] )
 	}
 
 	//Convert to centroid
-	core::pose::switch_to_residue_type_set( pose, chemical::CENTROID);
+	protocols::toolbox::switch_to_residue_type_set( pose, chemical::CENTROID);
 
 	vector1< pair<Size,Size> > cen_disulf;
 	core::conformation::disulfide_bonds(pose, cen_disulf);
@@ -123,7 +124,7 @@ int main( int argc, char * argv [] )
 	pose.dump_scored_pdb(outfile, *cen_sfxn, "");
 
 	//Convert to fa
-	core::pose::switch_to_residue_type_set( pose, chemical::FA_STANDARD);
+	protocols::toolbox::switch_to_residue_type_set( pose, chemical::FA_STANDARD);
 
 	vector1< pair<Size,Size> > fa_disulf;
 	core::conformation::disulfide_bonds(pose, fa_disulf);
diff --git a/src/apps/pilot/blivens/convert.cc b/src/apps/pilot/blivens/convert.cc
index 18c0991..e2d5995 100644
--- a/src/apps/pilot/blivens/convert.cc
+++ b/src/apps/pilot/blivens/convert.cc
@@ -43,6 +43,7 @@ using namespace basic::options::OptionKeys;
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 basic::Tracer TR( "pilot_apps.blivens.convert" );
@@ -98,8 +99,9 @@ int main( int argc, char * argv [] )
 	chemical::ResidueTypeSetCAP rsd_set =
 		chemical::ChemicalManager::get_instance()->residue_type_set(in_rsd_set);
 	pose::Pose pose;
+
 	core::import_pose::pose_from_pdb( pose, *rsd_set, pdb, false);
-	core::pose::switch_to_residue_type_set( pose, out_rsd_set);
+	protocols::toolbox::switch_to_residue_type_set( pose, out_rsd_set);
 	pose.dump_pdb(out);
 
 	return 0;
diff --git a/src/apps/pilot/blivens/disulfide_handoff.cc b/src/apps/pilot/blivens/disulfide_handoff.cc
index 9e9fcee..0eb8c4a 100644
--- a/src/apps/pilot/blivens/disulfide_handoff.cc
+++ b/src/apps/pilot/blivens/disulfide_handoff.cc
@@ -67,6 +67,7 @@ using namespace core::conformation;
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 basic::Tracer TR( "pilot_apps.blivens.disulfide_handoff" );
 
@@ -126,8 +127,8 @@ int main( int argc, char * argv [] )
 
 	//////////////////////
 	//Convert to centroid and back
-	//core::pose::switch_to_residue_type_set( cen_pose, chemical::CENTROID);
-	//core::pose::switch_to_residue_type_set( cen_pose, chemical::FA_STANDARD);
+	//protocols::toolbox::switch_to_residue_type_set( cen_pose, chemical::CENTROID);
+	//protocols::toolbox::switch_to_residue_type_set( cen_pose, chemical::FA_STANDARD);
 	//TR << "Writing fa version after conversion to "<< outfile+"_fa.pdb" << endl;
 	//cen_pose.dump_scored_pdb(outfile+"_fa.pdb",*sfxn,"fa");
 
diff --git a/src/apps/pilot/chrisk/pep_gly.cc b/src/apps/pilot/chrisk/pep_gly.cc
index 2db9b2a..300144c 100644
--- a/src/apps/pilot/chrisk/pep_gly.cc
+++ b/src/apps/pilot/chrisk/pep_gly.cc
@@ -154,6 +154,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -983,7 +984,7 @@ RunPepSpec()
 		pose.fold_tree( f );
 
 		//convert to CG residues//
-		core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+		protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 ////////////////////////////////////////////
 		Size pep_anchor( 2 );
 		if( option[ pep_spec::add_buffer_res ] ) add_pep_buffer_res( pose, pep_begin, pep_anchor, pep_end, true, false );
@@ -1013,7 +1014,7 @@ RunPepSpec()
 		}
 
 		//switch back to fullatom
-		core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+		protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 
 /*
 		//randomize pep sequence//
diff --git a/src/apps/pilot/chrisk/pep_prepspec.cc b/src/apps/pilot/chrisk/pep_prepspec.cc
index 58e165c..1c66e01 100644
--- a/src/apps/pilot/chrisk/pep_prepspec.cc
+++ b/src/apps/pilot/chrisk/pep_prepspec.cc
@@ -154,6 +154,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -1016,7 +1017,7 @@ RunPepSpec()
 			}
 		}
 		//convert to CG residues//
-		core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+		protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 
 		//add buffer res
 		bool add_nterm( true );
@@ -1090,7 +1091,7 @@ RunPepSpec()
 			}
 
 			//switch back to fullatom
-			core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+			protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 
 			//replace prot residues w/ original rotamers
 			for(Size resnum = prot_begin; resnum <= prot_end; ++resnum){
diff --git a/src/apps/pilot/chrisk/pep_ref.cc b/src/apps/pilot/chrisk/pep_ref.cc
index cff22d3..bb1742c 100644
--- a/src/apps/pilot/chrisk/pep_ref.cc
+++ b/src/apps/pilot/chrisk/pep_ref.cc
@@ -153,6 +153,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -804,7 +805,7 @@ RunPepSpec()
 		pose.fold_tree( f );
 
 		//convert to CG residues//
-		core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+		protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 
 		if( option[ pep_spec::cen_bb_frag ] ) pose = gen_pep_bb_frag( pose, pep_begin, pep_end, cen_scorefxn, lib );
 		else if( option[ pep_spec::cen_bb_rama ] ) pose = gen_pep_bb_rama( pose, pep_begin, pep_end, cen_scorefxn );
@@ -831,7 +832,7 @@ RunPepSpec()
 		}
 
 		//switch back to fullatom
-		core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+		protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 
 		//replace termini
 		core::pose::add_lower_terminus_type_to_pose_residue( pose, pep_begin );
diff --git a/src/apps/pilot/chrisk/pep_spec.03-11.cc b/src/apps/pilot/chrisk/pep_spec.03-11.cc
index 6f90465..e39d84f 100644
--- a/src/apps/pilot/chrisk/pep_spec.03-11.cc
+++ b/src/apps/pilot/chrisk/pep_spec.03-11.cc
@@ -145,6 +145,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
  using basic::T;
  using basic::Error;
@@ -656,7 +657,7 @@ RunPepSpec()
 		}
 
 		//convert to CG residues//
-		protocols::loops::core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+		protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 		( *cen_scorefxn )( pose );
 		cen_scorefxn->accumulate_residue_total_energies( pose );
 
@@ -778,7 +779,7 @@ RunPepSpec()
 				mc_cg->recover_low( pose );
 			}
 			//switch back to fullatom
-			protocols::loops::core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+			protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 
 			//replace kin residues w/ original rotamers
 			for(Size resnum = prot_begin; resnum <= prot_end; ++resnum){
@@ -1026,7 +1027,7 @@ RunPepSpec()
 				for( Size unbound_loop = 1; unbound_loop <= n_unbound_loop; ++unbound_loop ){
 					pep_eval_pose = pep_restart_pose;
 					if( option[ pep_spec::score_binding_refold ] && unbound_loop != 1 ){
-						protocols::loops::core::pose::switch_to_residue_type_set( pep_eval_pose, core::chemical::CENTROID );
+						protocols::loops::protocols::toolbox::switch_to_residue_type_set( pep_eval_pose, core::chemical::CENTROID );
 						core::scoring::ScoreFunctionOP pep_cen_scorefxn(  ScoreFunctionFactory::create_score_function( "cen_std.wts" ) );
 						( *pep_cen_scorefxn )( pep_eval_pose );
 						pep_cen_scorefxn->accumulate_residue_total_energies( pep_eval_pose );
@@ -1057,7 +1058,7 @@ RunPepSpec()
 							mc_pep_cen->boltzmann( pep_eval_pose );
 						}
 						mc_pep_cen->recover_low( pep_eval_pose );
-						protocols::loops::core::pose::switch_to_residue_type_set( pep_eval_pose, core::chemical::FA_STANDARD );
+						protocols::loops::protocols::toolbox::switch_to_residue_type_set( pep_eval_pose, core::chemical::FA_STANDARD );
 					}
 					if( option[ pep_spec::score_binding_repack ] ){
 						pack::task::PackerTaskOP pep_eval_task( pack::task::TaskFactory::create_packer_task( pep_eval_pose ));
diff --git a/src/apps/pilot/chrisk/pep_spec.06-23.cc b/src/apps/pilot/chrisk/pep_spec.06-23.cc
index c981bc5..091988f 100644
--- a/src/apps/pilot/chrisk/pep_spec.06-23.cc
+++ b/src/apps/pilot/chrisk/pep_spec.06-23.cc
@@ -154,6 +154,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -1068,7 +1069,7 @@ RunPepSpec()
 			}
 		}
 		//convert to CG residues//
-		core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+		protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 
 		//add buffer res
 		bool add_nterm( true );
@@ -1143,7 +1144,7 @@ RunPepSpec()
 			}
 
 			//switch back to fullatom
-			core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+			protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 
 			//replace prot residues w/ original rotamers
 			for(Size resnum = prot_begin; resnum <= prot_end; ++resnum){
diff --git a/src/apps/pilot/chrisk/pep_spec.cc b/src/apps/pilot/chrisk/pep_spec.cc
index 23d7932..8725fc6 100644
--- a/src/apps/pilot/chrisk/pep_spec.cc
+++ b/src/apps/pilot/chrisk/pep_spec.cc
@@ -154,6 +154,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -1120,7 +1121,7 @@ RunPepSpec()
 			}
 		}
 		//convert to CG residues//
-		core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+		protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 
 		//add buffer res
 		bool add_nterm( true );
@@ -1195,7 +1196,7 @@ RunPepSpec()
 			}
 
 			//switch back to fullatom
-			core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+			protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 
 			//replace prot residues w/ original rotamers
 			for(Size resnum = prot_begin; resnum <= prot_end; ++resnum){
diff --git a/src/apps/pilot/chrisk/pep_spec_flx.cc b/src/apps/pilot/chrisk/pep_spec_flx.cc
index 591e444..89b54f4 100644
--- a/src/apps/pilot/chrisk/pep_spec_flx.cc
+++ b/src/apps/pilot/chrisk/pep_spec_flx.cc
@@ -165,6 +165,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -1563,7 +1564,7 @@ RunPepSpec()
 		Residue pep_anchor_res = pose.residue( pep_anchor );
 
 		//convert to CG residues//
-		if( !option[ pep_spec::no_cen ] ) core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+		if( !option[ pep_spec::no_cen ] ) protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 		( *cen_scorefxn )( pose );
 
 		//small RB diversify//
@@ -1685,7 +1686,7 @@ RunPepSpec()
 				core::pose::remove_variant_type_from_pose_residue( pose, "VIRTUAL_BB", pep_begin );
 				core::pose::remove_variant_type_from_pose_residue( pose, "VIRTUAL_BB", pep_end );
 			}
-			core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+			protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 			if( option[ pep_spec::add_buffer_res ] ){
 				core::pose::add_variant_type_to_pose_residue( pose, "VIRTUAL_BB", pep_begin );
 				core::pose::add_variant_type_to_pose_residue( pose, "VIRTUAL_BB", pep_end );
diff --git a/src/apps/pilot/chrisk/pep_spec_flx.mov.cc b/src/apps/pilot/chrisk/pep_spec_flx.mov.cc
index 60b83a7..8d3de2e 100644
--- a/src/apps/pilot/chrisk/pep_spec_flx.mov.cc
+++ b/src/apps/pilot/chrisk/pep_spec_flx.mov.cc
@@ -158,6 +158,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -1386,7 +1387,7 @@ RunPepSpec()
 		Residue pep_anchor_res = pose.residue( pep_anchor );
 
 		//convert to CG residues//
-		core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+		protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 		( *cen_scorefxn )( pose );
 
 		MonteCarloOP mc_rb ( new MonteCarlo( pose, *cen_scorefxn, 1.0 ) );
@@ -1510,7 +1511,7 @@ RunPepSpec()
 				core::pose::remove_variant_type_from_pose_residue( pose, "VIRTUAL_BB", pep_begin );
 				core::pose::remove_variant_type_from_pose_residue( pose, "VIRTUAL_BB", pep_end );
 			}
-			core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+			protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 			if( option[ pep_spec::add_buffer_res ] ){
 				core::pose::add_variant_type_to_pose_residue( pose, "VIRTUAL_BB", pep_begin );
 				core::pose::add_variant_type_to_pose_residue( pose, "VIRTUAL_BB", pep_end );
diff --git a/src/apps/pilot/dgront/JumpSpecificAbrelax.cc b/src/apps/pilot/dgront/JumpSpecificAbrelax.cc
index 4921c76..f74054b 100644
--- a/src/apps/pilot/dgront/JumpSpecificAbrelax.cc
+++ b/src/apps/pilot/dgront/JumpSpecificAbrelax.cc
@@ -187,6 +187,7 @@
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -501,7 +502,7 @@ void JumpSpecificAbrelax::setup() {
 		boinc::Boinc::set_graphics_native_pose( *native_pose_ );
 #endif
 
-		core::pose::switch_to_residue_type_set( *native_pose_, chemical::CENTROID ); //so that in do_rerun the native pose is the same as the other poses
+		protocols::toolbox::switch_to_residue_type_set( *native_pose_, chemical::CENTROID ); //so that in do_rerun the native pose is the same as the other poses
 		//		for ( Size i = 1; i<=native_pose_->total_residue(); i++ ) {
 		//			std::cout << native_pose_->phi(i) << ' ' << native_pose_->psi(i) << std::endl;
 		//		}
@@ -1054,12 +1055,12 @@ void JumpSpecificAbrelax::do_distributed_rerun() {
 		// don't relax if we failed filters or loop_closing, or if option[ relax_with_jumps ] is true
 		bool bCanRelax = passes_filters && ( !loop_closure_failed || option[ OptionKeys::abinitio::relax_with_jumps ]() );
 		if ( bRelax_ ) {
-			if ( !pose.is_fullatom() ) core::pose::switch_to_residue_type_set( pose, chemical::FA_STANDARD );
+			if ( !pose.is_fullatom() ) protocols::toolbox::switch_to_residue_type_set( pose, chemical::FA_STANDARD );
 			if ( bCanRelax ) {
 				relax( pose, fullatom_scorefxn, jobdist.get_current_output_tag() );
 			} else { //cannot relax
 				//need proper atom set to score with full-atom
-				//				if ( !pose.is_fullatom() ) core::pose::switch_to_residue_type_set( pose, chemical::FA_STANDARD );
+				//				if ( !pose.is_fullatom() ) protocols::toolbox::switch_to_residue_type_set( pose, chemical::FA_STANDARD );
 			}
 		} // if ( bRelax_ )
 
@@ -1807,7 +1808,7 @@ void JumpSpecificAbrelax::fold() {
 				if ( !option[ OptionKeys::loopfcst::use_general_protocol ] ) {
 					//					utility_exit_with_message("Cannot proceed (about to crash), because pose is fullatom and loopcose expects centroid. Use -use_general_protocol if you want to postrelax foldcst models.");
 				//This part of code i think is obsolete and will soon disappear.");
-					if ( !fold_pose.is_fullatom() ) core::pose::switch_to_residue_type_set( fold_pose, chemical::FA_STANDARD );
+					if ( !fold_pose.is_fullatom() ) protocols::toolbox::switch_to_residue_type_set( fold_pose, chemical::FA_STANDARD );
 				}
 				if ( bCanRelax ) {
 					if ( option[ basic::options::OptionKeys::abinitio::multifastrelax ]() ) {
@@ -1816,14 +1817,14 @@ void JumpSpecificAbrelax::fold() {
 						if ( bEndrun ) break;
 					} else {
 						fold_pose.constraint_set( NULL );
-						//if ( abinitio_protocol.return_centroid() ) core::pose::switch_to_residue_type_set( fold_pose, chemical::FA_STANDARD );
-						if ( !fold_pose.is_fullatom() ) core::pose::switch_to_residue_type_set( fold_pose, chemical::FA_STANDARD );
+						//if ( abinitio_protocol.return_centroid() ) protocols::toolbox::switch_to_residue_type_set( fold_pose, chemical::FA_STANDARD );
+						if ( !fold_pose.is_fullatom() ) protocols::toolbox::switch_to_residue_type_set( fold_pose, chemical::FA_STANDARD );
 						relax( fold_pose, fullatom_scorefxn, jobdist.get_current_output_tag() );
 					}
 				} else { //cannot relax
 					//need proper atom set to score with full-atom
 					if ( !fold_pose.is_fullatom() ) {
-						core::pose::switch_to_residue_type_set( fold_pose, chemical::FA_STANDARD );
+						protocols::toolbox::switch_to_residue_type_set( fold_pose, chemical::FA_STANDARD );
 					}
 					(*fullatom_scorefxn)( fold_pose );
 					if ( option[ basic::options::OptionKeys::abinitio::fastrelax ]() ) {	//FastRelax adds another two columns, grr
@@ -1899,7 +1900,7 @@ void JumpSpecificAbrelax::fold() {
 							relax( *it, fullatom_scorefxn, current_tag );
 						} else { //cannot relax
 							//need proper atom set to score with full-atom
-							if ( !it->is_fullatom() ) core::pose::switch_to_residue_type_set( *it, chemical::FA_STANDARD );
+							if ( !it->is_fullatom() ) protocols::toolbox::switch_to_residue_type_set( *it, chemical::FA_STANDARD );
 							(*fullatom_scorefxn)( *it );
 							if ( option[ basic::options::OptionKeys::abinitio::fastrelax ]() ) {	//FastRelax adds another two columns, grr
 								relax::FastRelax::setPoseExtraScores(  *it );
@@ -1961,7 +1962,7 @@ bool JumpSpecificAbrelax::multi_fast_relax(
 		protocols::boinc::Boinc::attach_graphics_current_pose_observer( cpose );
 #endif
 
-		core::pose::switch_to_residue_type_set( cpose, chemical::FA_STANDARD );
+		protocols::toolbox::switch_to_residue_type_set( cpose, chemical::FA_STANDARD );
 
 		FastRelax fast_relax( scorefxn );
 		// for making checkpoint tag unique
diff --git a/src/apps/pilot/dgront/saxs/linker_sampler.cc b/src/apps/pilot/dgront/saxs/linker_sampler.cc
index 6a882ec..5e9a861 100644
--- a/src/apps/pilot/dgront/saxs/linker_sampler.cc
+++ b/src/apps/pilot/dgront/saxs/linker_sampler.cc
@@ -59,6 +59,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 basic::Tracer TR("linker_sampler");
@@ -104,7 +105,8 @@ public:
         core::chemical::ResidueTypeSetCAP rsd_set_cen = core::chemical::ChemicalManager::get_instance()->residue_type_set( "centroid" );
         core::chemical::ResidueTypeSetCAP rsd_set_fa = core::chemical::ChemicalManager::get_instance()->residue_type_set( "fa_standard" );
 	core::import_pose::pose_from_pdb( cen_pose_, option[in::file::s]()[1].name());
-	core::pose::switch_to_residue_type_set(cen_pose_, core::chemical::CENTROID);
+	protocols::toolbox::switch_to_residue_type_set(cen_pose_, core::chemical::CENTROID);
+
 
 
 //------------- set up sampling  -----------------
@@ -165,7 +167,7 @@ public:
 
 // ------------- Switch to all-atom --------------------------
 	    core::pose::Pose fa_pose(cen_pose_);
-	    core::pose::switch_to_residue_type_set( fa_pose, core::chemical::FA_STANDARD);
+	    protocols::toolbox::switch_to_residue_type_set( fa_pose, core::chemical::FA_STANDARD);
 //	    cen_pose_.conformation().detect_bonds();//apl fix this !
 
 // ------------- Relax  --------------------------
diff --git a/src/apps/pilot/kuichan/design_disulfide.cc b/src/apps/pilot/kuichan/design_disulfide.cc
index 4c75eea..8fcc8e3 100644
--- a/src/apps/pilot/kuichan/design_disulfide.cc
+++ b/src/apps/pilot/kuichan/design_disulfide.cc
@@ -42,7 +42,7 @@
 #include <core/chemical/ChemicalManager.hh>
 
 #include <protocols/toolbox/pose_manipulation.hh>
-
+#include <protocols/toolbox/disulfide_util.hh>
 //Packing
 #include <core/pack/rotamer_trials.hh>
 #include <core/pack/task/PackerTask.hh>
@@ -55,7 +55,6 @@
 #include <core/scoring/ScoreFunction.hh>
 #include <core/scoring/ScoreFunctionFactory.hh>
 
-#include <core/pose/disulfide_util.hh>
 #include <core/chemical/util.hh>
 #include <fstream>
 #include <iostream>
@@ -75,6 +74,7 @@ using namespace basic::options::OptionKeys;
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 basic::Tracer TR( "pilot_apps.kuichan.design_disulfide" );
@@ -129,7 +129,7 @@ int main( int argc, char * argv [] )
 
 	string out_rsd_set = chemical::CENTROID;
 	TR.Info << "Converting from " << in_rsd_set <<" to " << out_rsd_set << endl;
-	core::pose::switch_to_residue_type_set( pose, out_rsd_set);
+	protocols::toolbox::switch_to_residue_type_set( pose, out_rsd_set);
 
 	//Write out temp PDB
 	pose.dump_pdb(out);
@@ -166,7 +166,7 @@ int main( int argc, char * argv [] )
 
 	//convert back to full atoms and build disufide bonds
 	TR.Info << "Converting from " << in_rsd_set << " to " << out_rsd_set << endl;
-	core::pose::switch_to_residue_type_set( pose, out_rsd_set);
+	protocols::toolbox::switch_to_residue_type_set( pose, out_rsd_set);
 
 	utility::vector1< std::pair<core::Size,core::Size> >  NumDisulfides;
 	core::conformation::disulfide_bonds ( pose.conformation(), NumDisulfides );
@@ -217,7 +217,7 @@ int main( int argc, char * argv [] )
 		disulf_pose->conformation().fix_disulfides( disulfides );
 
 		scoring::ScoreFunctionOP sfxn = scoring::getScoreFunction();
-		core::pose::rebuild_disulfide(*disulf_pose,disulfides,NULL,sfxn,NULL,sfxn);
+		protocols::toolbox::rebuild_disulfide(*disulf_pose,disulfides,NULL,sfxn,NULL,sfxn);
 		TR.Info << "relax:" << disulf_out.str() << std::endl;
 		protocols::relax::relax_pose(*disulf_pose,sfxn,disulf_out.str());
 
diff --git a/src/apps/pilot/mike/loophash.cc b/src/apps/pilot/mike/loophash.cc
index 1b9b967..d42c322 100644
--- a/src/apps/pilot/mike/loophash.cc
+++ b/src/apps/pilot/mike/loophash.cc
@@ -92,6 +92,7 @@
 #include <core/pose/Pose.hh>
 #include <core/pose/util.hh>
 #include <core/util/datacache/CacheableData.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -176,7 +177,7 @@ LoopHashRelax_Sampler::apply( core::pose::Pose& pose )
     protocols::relax::FastRelax *relax = new protocols::relax::FastRelax( fascorefxn,  option[ OptionKeys::relax::sequence_file ]() );
 
     // convert pose to centroid pose:
-    core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID);
+    protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID);
     core::pose::set_ss_from_phipsi( pose );
 
     core::Size starttime2 = time(NULL);
@@ -358,7 +359,7 @@ void run_sandbox( LoopHashLibraryOP /*loop_hash_library*/ ){
 //    std::cout << pss.mem_footprint() << "  " << ss.str().length() << std::endl;
 //  }
 
-  core::pose::switch_to_residue_type_set( tgtpose, core::chemical::CENTROID);
+  protocols::toolbox::switch_to_residue_type_set( tgtpose, core::chemical::CENTROID);
 
 
   {
diff --git a/src/apps/pilot/mike/loophash_mpi.cc b/src/apps/pilot/mike/loophash_mpi.cc
index 10f955a..4c98b4b 100644
--- a/src/apps/pilot/mike/loophash_mpi.cc
+++ b/src/apps/pilot/mike/loophash_mpi.cc
@@ -35,6 +35,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 class MPI_LoopHash_Launcher {
@@ -52,7 +53,7 @@ class MPI_LoopHash_Launcher {
 			native_pose_ = new core::pose::Pose();
 			core::import_pose::pose_from_pdb( *native_pose_, option[ in::file::native ]() );
 			core::pose::set_ss_from_phipsi( *native_pose_ );
-			core::pose::switch_to_residue_type_set( *native_pose_, core::chemical::CENTROID);
+			protocols::toolbox::switch_to_residue_type_set( *native_pose_, core::chemical::CENTROID);
 		}
 
 		WorkUnitList wulist;
diff --git a/src/apps/pilot/olli/helper_code_r_trjconv.cc b/src/apps/pilot/olli/helper_code_r_trjconv.cc
index fc2eca7..a952215 100644
--- a/src/apps/pilot/olli/helper_code_r_trjconv.cc
+++ b/src/apps/pilot/olli/helper_code_r_trjconv.cc
@@ -3,6 +3,7 @@
 //Auto Headers
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 // (c) This file is part of the Rosetta software suite and is made available under license.
 // (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
@@ -72,7 +73,7 @@ core::pose::make_pose_from_sequence_(
 ///will be copied. Redundant atoms will be removed (in case from fullatom to centroid) and missing atoms will be
 ///built by ideal geometry (in the case from centroid to fullatom).
 void
-core::pose::switch_to_residue_type_set(
+protocols::toolbox::switch_to_residue_type_set(
 				 pose::Pose & pose,
 				 std::string const & type_set_name
 )
@@ -88,7 +89,7 @@ core::pose::switch_to_residue_type_set(
 		// in future we may have a conformation using mixed type set, so check this by residue
 		std::string const & current_type_set_name ( rsd.type().residue_type_set().database_directory() );
 		if ( current_type_set_name.find( type_set_name ) != std::string::npos ) {
-			std::cerr << "core::pose::switch_to_residue_type_set: residue " << i << "already in " << type_set_name
+			std::cerr << "protocols::toolbox::switch_to_residue_type_set: residue " << i << "already in " << type_set_name
 								<< " residue_type_set" << '\n';
 			continue;
 		}
@@ -106,7 +107,7 @@ core::pose::switch_to_residue_type_set(
 		if ( ! new_rsd ) {
 			std::cerr << "can not find a residue type that matches the residue " << rsd.name()
 		<< "at position " << i << '\n';
-			utility_exit_with_message( "core::pose::switch_to_residue_type_set fails\n" );
+			utility_exit_with_message( "protocols::toolbox::switch_to_residue_type_set fails\n" );
 		}
 		// switch to corresponding residue type in the new set.
 		pose.replace_residue( i, *new_rsd, false );
diff --git a/src/apps/pilot/olli/r_check_chainbreak.cc b/src/apps/pilot/olli/r_check_chainbreak.cc
index 3f3e978..d129192 100644
--- a/src/apps/pilot/olli/r_check_chainbreak.cc
+++ b/src/apps/pilot/olli/r_check_chainbreak.cc
@@ -105,6 +105,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -171,7 +172,7 @@ void Application::setup() {
   if ( option[ in::file::native ].user() ) {
     native_pose_ = new pose::Pose;
     core::import_pose::pose_from_pdb( *native_pose_, option[ in::file::native ]() );
-    core::pose::switch_to_residue_type_set( *native_pose_, chemical::CENTROID ); //so that in do_rerun the native pose is the same as the other poses
+    protocols::toolbox::switch_to_residue_type_set( *native_pose_, chemical::CENTROID ); //so that in do_rerun the native pose is the same as the other poses
     pose::set_ss_from_phipsi( *native_pose_ );
   }
 }
diff --git a/src/apps/pilot/olli/r_fold_cst.cc b/src/apps/pilot/olli/r_fold_cst.cc
index 9577a5e..90822cf 100644
--- a/src/apps/pilot/olli/r_fold_cst.cc
+++ b/src/apps/pilot/olli/r_fold_cst.cc
@@ -128,6 +128,7 @@ using namespace core;
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -297,7 +298,7 @@ void ThisApplication::setup() {
 	// read native pose
 	native_pose_ = new pose::Pose;
 	core::import_pose::pose_from_pdb( *native_pose_, option[ in::file::native ]() );
-	core::pose::switch_to_residue_type_set( *native_pose_, chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( *native_pose_, chemical::CENTROID );
 
 	// specify sequence -- from fasta file or native_pose
 	if ( option [ in::file::fasta ].user() ) {
diff --git a/src/apps/pilot/olli/r_frag_picker.cc b/src/apps/pilot/olli/r_frag_picker.cc
index 6b192a3..aacea05 100644
--- a/src/apps/pilot/olli/r_frag_picker.cc
+++ b/src/apps/pilot/olli/r_frag_picker.cc
@@ -62,6 +62,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -136,7 +137,7 @@ void ThisApplication::setup() {
   //read it
 	std::string pdb_file( option[ pick::f ]() );
   core::import_pose::pose_from_pdb( aligned_, pdb_file );
-  //core::pose::switch_to_residue_type_set( aligned_, chemical::CENTROID );
+  //protocols::toolbox::switch_to_residue_type_set( aligned_, chemical::CENTROID );
 
   //idealize
   if ( !option[ pick::no_idealize ] ) {
diff --git a/src/apps/pilot/olli/r_frag_quality.cc b/src/apps/pilot/olli/r_frag_quality.cc
index c106939..afb8a37 100644
--- a/src/apps/pilot/olli/r_frag_quality.cc
+++ b/src/apps/pilot/olli/r_frag_quality.cc
@@ -69,6 +69,7 @@
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 #include <numeric/xyz.functions.hh>
 #include <ObjexxFCL/format.hh>
 
@@ -734,7 +735,7 @@ int main( int argc, char** argv ) {
 	Pose native;
 	//read it
 	core::import_pose::pose_from_pdb( native, native_pdb );
-	core::pose::switch_to_residue_type_set( native, chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( native, chemical::CENTROID );
 
 	Pose test_pose;
 	core::pose::make_pose_from_sequence(
diff --git a/src/apps/pilot/olli/r_local_rdc.cc b/src/apps/pilot/olli/r_local_rdc.cc
index 5ad87a3..084c232 100644
--- a/src/apps/pilot/olli/r_local_rdc.cc
+++ b/src/apps/pilot/olli/r_local_rdc.cc
@@ -75,6 +75,7 @@
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -270,7 +271,7 @@ int main( int argc, char** argv ) {
   //read it
   std::string const native_pdb ( option[ in::file::native ]() );
   core::import_pose::pose_from_pdb( native, native_pdb );
-  core::pose::switch_to_residue_type_set( native, chemical::CENTROID );
+  protocols::toolbox::switch_to_residue_type_set( native, chemical::CENTROID );
 
   Pose test_pose;
 	Pose clean_pose;
diff --git a/src/apps/pilot/olli/r_noe_assign.cc b/src/apps/pilot/olli/r_noe_assign.cc
index dd1c89b..6dc0201 100644
--- a/src/apps/pilot/olli/r_noe_assign.cc
+++ b/src/apps/pilot/olli/r_noe_assign.cc
@@ -49,6 +49,7 @@
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 static basic::Tracer tr("main");
@@ -218,7 +219,7 @@ void run_old() {
 
 // 	core::scoring::constraints::ConstraintSetOP centroid_cstset = cpl.generate_constraints( pose, true );
 // 	core::pose::Pose centroid_pose = pose;
-// 	core::pose::switch_to_residue_type_set( centroid_pose, core::chemical::CENTROID );
+// 	protocols::toolbox::switch_to_residue_type_set( centroid_pose, core::chemical::CENTROID );
 // 	core::scoring::constraints::ConstraintIO::write_constraints(  basic::options::option[ basic::options::OptionKeys::cst_out ]().name()
 // 		+ ".centroid", *centroid_cstset, centroid_pose );
 
diff --git a/src/apps/pilot/olli/r_trjconv.cc b/src/apps/pilot/olli/r_trjconv.cc
index 1da70cc..842c108 100644
--- a/src/apps/pilot/olli/r_trjconv.cc
+++ b/src/apps/pilot/olli/r_trjconv.cc
@@ -100,6 +100,7 @@ using namespace abinitio;
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
 #include <core/scoring/constraints/Constraint.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 #include <utility/excn/EXCN_Base.hh>
 
 
@@ -144,12 +145,12 @@ void ThisApplication::register_options() {
 /// why was this function duplicated here? another copy lives in core/chemical/util.cc/hh, which seems like a better
 /// place for it.
 void
-core::pose::switch_to_residue_type_set(
+protocols::toolbox::switch_to_residue_type_set(
 	pose::Pose & pose,
 	std::string const & type_set_name
 )
 {
-	core::pose::switch_to_residue_type_set( pose, type_set_name );
+	protocols::toolbox::switch_to_residue_type_set( pose, type_set_name );
 }
 
 void compute_chi( pose::Pose &pose ) {
diff --git a/src/apps/pilot/phil/capri15.cc b/src/apps/pilot/phil/capri15.cc
index b681cdb..67faecb 100644
--- a/src/apps/pilot/phil/capri15.cc
+++ b/src/apps/pilot/phil/capri15.cc
@@ -143,6 +143,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -788,7 +789,7 @@ sample_rna_dofs_new(
 
 			if ( !fa_output ) pose.dump_pdb( filename );
 			else {
-				protocols::loops::core::pose::switch_to_residue_type_set( pose, FA_STANDARD );
+				protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, FA_STANDARD );
 
 				if ( fa_relax ) {
 					setup_sam_constraints_for_t033( pose );
@@ -867,7 +868,7 @@ capri_t033_centroid_trim_dock_test()
 
 			setup_capri_data( pose, pssm_file, mapping_from_t033_to_pose );
 
-			protocols::loops::core::pose::switch_to_residue_type_set( pose, chemical::HYBRID_FA_STANDARD_CENTROID );
+			protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, chemical::HYBRID_FA_STANDARD_CENTROID );
 
 			//pose.dump_pdb( "switched.pdb" );
 
@@ -920,7 +921,7 @@ trim_dock_rebuild_relax_test_rhiju()
 
 			setup_capri_data( pose, pssm_file, mapping_from_t033_to_pose );
 
-			protocols::loops::core::pose::switch_to_residue_type_set( pose, chemical::HYBRID_FA_STANDARD_CENTROID );
+			protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, chemical::HYBRID_FA_STANDARD_CENTROID );
 
 			sample_rna_dofs_new( pose, tag, 10, t033_seq, mapping_from_t033_to_pose, ss_map, true );
 		}
@@ -1028,7 +1029,7 @@ trim_dock_rebuild_relax_test()
 
 			setup_capri_data( pose, pssm_file, mapping_from_t033_to_pose );
 
-			protocols::loops::core::pose::switch_to_residue_type_set( pose, chemical::HYBRID_FA_STANDARD_CENTROID );
+			protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, chemical::HYBRID_FA_STANDARD_CENTROID );
 
 			sample_rna_dofs_new( pose, tag, 1, t033_seq, mapping_from_t033_to_pose, ss_map, false );
 
@@ -1122,7 +1123,7 @@ setup_sam_constraints_for_t033(
 
 }
 
-/// begins with full protein repack with soft soft rep, so can call immediately after core::pose::switch_to_residue_type_set(FA)
+/// begins with full protein repack with soft soft rep, so can call immediately after protocols::toolbox::switch_to_residue_type_set(FA)
 
 void
 juke_sam_pos(
@@ -1612,7 +1613,7 @@ centroid_rescore_test()
 
 
 		// now rescore with loop scorefxn, 1st try
-		protocols::loops::core::pose::switch_to_residue_type_set( pose, HYBRID_FA_STANDARD_CENTROID );
+		protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, HYBRID_FA_STANDARD_CENTROID );
 		score = (*loop_scorefxn)(pose);
 		std::cout << "rescore_loop: " << start_files()[n] << ' ' << score << ' ' << n_protein_rna_nbrs << ' ' <<
 			pose.energies().total_energies().weighted_string_of( loop_scorefxn->weights() ) << std::endl;
@@ -1704,7 +1705,7 @@ diversify_sam_loop_test()
 		pose.conformation().delete_residue_slow( sam_pos );
 		for ( Size i=1; i<= pose.total_residue(); ++i ) assert( pose.residue(i).is_protein() );
 
-		protocols::loops::core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+		protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 
 		//// setup for rebuilding the loop under the sam
 		Size const cutpoint( loop_begin - 1 + static_cast< int >( numeric::random::uniform() * (loop_size+1)) );
@@ -1727,7 +1728,7 @@ diversify_sam_loop_test()
 
 		util::prof_show();
 
-		protocols::loops::core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+		protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 
 		Size sam_anchor_pos( loops.begin()->stop() + 1 );
 		assert(  loops.is_loop_residue( loops.begin()->start() ) );
@@ -2077,7 +2078,7 @@ capri_t033_loop_test()
 				if ( !pose.residue(i).is_protein() ) pose.conformation().delete_residue_slow( i );
 			}
 
-			protocols::loops::core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+			protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 
 			// for graphics:
 			//protocols::viewer::add_conformation_viewer( pose.conformation(), "loops_pose" );
@@ -2088,7 +2089,7 @@ capri_t033_loop_test()
 
 			util::prof_show();
 
-			protocols::loops::core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+			protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 
 			// create a fullatom scorefxn
 			ScoreFunctionOP scorefxn
diff --git a/src/apps/pilot/phil/dna_dr_test.cc b/src/apps/pilot/phil/dna_dr_test.cc
index 8efd571..ff6a983 100644
--- a/src/apps/pilot/phil/dna_dr_test.cc
+++ b/src/apps/pilot/phil/dna_dr_test.cc
@@ -134,6 +134,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -581,7 +582,7 @@ loop_modeling_test()
 		Pose cen_pose;
 		cen_pose = pose;
 
-		protocols::loops::core::pose::switch_to_residue_type_set( pose, FA_STANDARD );
+		protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, FA_STANDARD );
 
 		for ( Size i=1; i<= pose.total_residue(); ++i ) {
 			Residue const &     rsd(     pose.residue(i) );
diff --git a/src/apps/pilot/phil/dna_spec_test.cc b/src/apps/pilot/phil/dna_spec_test.cc
index 3e244a0..ef4c58a 100644
--- a/src/apps/pilot/phil/dna_spec_test.cc
+++ b/src/apps/pilot/phil/dna_spec_test.cc
@@ -151,6 +151,7 @@
 #include <core/pose/util.hh>
 #include <core/scoring/methods/EnergyMethodOptions.hh>
 #include <protocols/frags/TorsionFragment.fwd.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 #include <ObjexxFCL/format.hh>
 
 
@@ -2763,7 +2764,7 @@ loop_modeling_test()
 		Pose cen_pose;
 		cen_pose = pose;
 
-		core::pose::switch_to_residue_type_set( pose, FA_STANDARD );
+		protocols::toolbox::switch_to_residue_type_set( pose, FA_STANDARD );
 
 		for ( Size i=1; i<= pose.total_residue(); ++i ) {
 			Residue const &     rsd(     pose.residue(i) );
diff --git a/src/apps/pilot/phil/simple_dna_regression_test.cc b/src/apps/pilot/phil/simple_dna_regression_test.cc
index e9dcaa5..3589312 100644
--- a/src/apps/pilot/phil/simple_dna_regression_test.cc
+++ b/src/apps/pilot/phil/simple_dna_regression_test.cc
@@ -141,6 +141,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -2829,7 +2830,7 @@ loop_modeling_test()
 		Pose cen_pose;
 		cen_pose = pose;
 
-		protocols::loops::core::pose::switch_to_residue_type_set( pose, FA_STANDARD );
+		protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, FA_STANDARD );
 
 		for ( Size i=1; i<= pose.total_residue(); ++i ) {
 			Residue const &     rsd(     pose.residue(i) );
diff --git a/src/apps/pilot/rhiju/stepwise_test.cc b/src/apps/pilot/rhiju/stepwise_test.cc
index 32829dd..147c914 100644
--- a/src/apps/pilot/rhiju/stepwise_test.cc
+++ b/src/apps/pilot/rhiju/stepwise_test.cc
@@ -163,6 +163,7 @@ using basic::T;
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -284,7 +285,7 @@ sample_rama_test()
 
 	pose::PoseOP native_pose = pose_op;
 	pose::Pose fa_pose = pose;
-	core::pose::switch_to_residue_type_set( pose, CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( pose, CENTROID );
 
 	protocols::viewer::add_conformation_viewer( pose.conformation(), "current", 400, 400 );
 
diff --git a/src/apps/pilot/smlewis/hect/HECT.hh b/src/apps/pilot/smlewis/hect/HECT.hh
index 239cbb7..362fe6c 100644
--- a/src/apps/pilot/smlewis/hect/HECT.hh
+++ b/src/apps/pilot/smlewis/hect/HECT.hh
@@ -37,10 +37,10 @@
 
 #include <core/pack/task/TaskFactory.hh>
 #include <core/pack/task/operation/TaskOperations.hh>
-#include <protocols/toolbox/task_operations/RestrictByCalculatorsOperation.hh>
-#include <protocols/toolbox/task_operations/RestrictToNeighborhoodOperation.hh>
+#include <protocols/toolbox/TaskOperations/RestrictByCalculatorsOperation.hh>
+#include <protocols/toolbox/TaskOperations/RestrictToNeighborhoodOperation.hh>
 #include <core/pose/metrics/CalculatorFactory.hh>
-#include <protocols/toolbox/pose_metric_calculators/InterGroupNeighborsCalculator.hh>
+#include <protocols/toolbox/PoseMetricCalculators/InterGroupNeighborsCalculator.hh>
 
 #include <core/scoring/ScoreFunctionFactory.hh>
 #include <core/scoring/ScoreFunction.hh>
@@ -72,51 +72,51 @@
 
 // Utility Headers
 #include <devel/init.hh>
-#include <basic/options/option.hh>
-#include <basic/Tracer.hh>
+#include <core/options/option.hh>
+#include <core/util/Tracer.hh>
 #include <numeric/xyz.functions.hh>
 
 // option key includes
-#include <basic/options/keys/run.OptionKeys.gen.hh>
-#include <basic/options/keys/in.OptionKeys.gen.hh>
-#include <basic/options/keys/packing.OptionKeys.gen.hh>
+#include <core/options/keys/run.OptionKeys.gen.hh>
+#include <core/options/keys/in.OptionKeys.gen.hh>
+#include <core/options/keys/packing.OptionKeys.gen.hh>
 
 #include <set>
 #include <utility>
 
-using basic::T;
-using basic::Error;
-using basic::Warning;
+using core::util::T;
+using core::util::Error;
+using core::util::Warning;
 
-static basic::Tracer TR("apps.pilot.smlewis.HECT");
+static core::util::Tracer TR("apps.pilot.smlewis.HECT");
 
-namespace basic{ namespace options{ namespace OptionKeys{
-basic::options::IntegerOptionKey const e3_hinge_start_resnum("e3_hinge_start_resnum");
-basic::options::IntegerOptionKey const e3_hinge_stop_resnum("e3_hinge_stop_resnum");
-basic::options::StringOptionKey const e3_hinge_chain("e3_hinge_chain");
-basic::options::IntegerOptionKey const e3_catalytic_resnum("e3_catalytic_resnum");
+namespace core{ namespace options{ namespace OptionKeys{
+core::options::IntegerOptionKey const e3_hinge_start_resnum("e3_hinge_start_resnum");
+core::options::IntegerOptionKey const e3_hinge_stop_resnum("e3_hinge_stop_resnum");
+core::options::StringOptionKey const e3_hinge_chain("e3_hinge_chain");
+core::options::IntegerOptionKey const e3_catalytic_resnum("e3_catalytic_resnum");
 
-basic::options::IntegerOptionKey const UBQ_tail_start_resnum("UBQ_tail_start_resnum");
-basic::options::StringOptionKey const UBQ_tail_chain("UBQ_tail_chain");
+core::options::IntegerOptionKey const UBQ_tail_start_resnum("UBQ_tail_start_resnum");
+core::options::StringOptionKey const UBQ_tail_chain("UBQ_tail_chain");
 
-basic::options::StringOptionKey const e2_chain("e2_chain");
-basic::options::IntegerOptionKey const e2_catalytic_resnum("e2_catalytic_resnum");
+core::options::StringOptionKey const e2_chain("e2_chain");
+core::options::IntegerOptionKey const e2_catalytic_resnum("e2_catalytic_resnum");
 
-basic::options::BooleanOptionKey const debug_skip_fragment_generation("debug_skip_fragment_generation");
-basic::options::BooleanOptionKey const debug("debug");
+core::options::BooleanOptionKey const debug_skip_fragment_generation("debug_skip_fragment_generation");
+core::options::BooleanOptionKey const debug("debug");
 
-basic::options::IntegerOptionKey const cycles("cycles");
-basic::options::IntegerOptionKey const repack_cycles("cycles");
+core::options::IntegerOptionKey const cycles("cycles");
+core::options::IntegerOptionKey const repack_cycles("cycles");
 
-basic::options::RealOptionKey const catalytic_cst_sd("catalytic_cst_sd");
-basic::options::RealOptionKey const ubq_cst_sd("ubq_cst_sd");
+core::options::RealOptionKey const catalytic_cst_sd("catalytic_cst_sd");
+core::options::RealOptionKey const ubq_cst_sd("ubq_cst_sd");
 
-}}}//basic::options::OptionKeys
+}}}//core::options::OptionKeys
 
 ///@brief utility function to register options
 void register_options(){
-	using basic::options::option;
-	using namespace basic::options::OptionKeys;
+	using core::options::option;
+	using namespace core::options::OptionKeys;
 	option.add( e3_hinge_start_resnum, "" );
 	option.add( e3_hinge_stop_resnum, "" );
 	option.add( e3_hinge_chain, "" );
@@ -200,7 +200,7 @@ public:
 
 		//read native structure for CA RMSD
 		core::pose::Pose xtal_pose;
-		core::io::pdb::pose_from_pdb(xtal_pose, basic::options::option[basic::options::OptionKeys::in::file::native].value());
+		core::import_pose::pose_from_pdb(xtal_pose, core::options::option[core::options::OptionKeys::in::file::native].value());
 		xtal_pose_ = new core::pose::Pose(xtal_pose);
 	}
 
@@ -212,7 +212,7 @@ public:
 		std::string ss_string(frags_length, 'L');
 		core::fragment::FragDataList list;
 
-		if(!basic::options::option[basic::options::OptionKeys::debug_skip_fragment_generation].value()){
+		if(!core::options::option[core::options::OptionKeys::debug_skip_fragment_generation].value()){
 			for (core::Size j = start; j <= stop-frags_length+1; ++j){
 				std::string const seqsubstr(seq, j-1, frags_length); //j-1 accounts for string [] from 0
 				TR << "adding frame, start at " << j << " go for " << frags_length << " to " << j+frags_length << " seq " << seqsubstr << std::endl;
@@ -231,8 +231,8 @@ public:
 	parse_options(core::pose::Pose const & pose) {
 
 		//determine where the flexible regions are
-		using namespace basic::options;
-		using namespace basic::options::OptionKeys;
+		using namespace core::options;
+		using namespace core::options::OptionKeys;
 
 		//there should only be 3 chains in the input pose
 		runtime_assert(pose.conformation().num_chains() == 3);
@@ -298,8 +298,8 @@ public:
 	///@brief some shared setup of task factory
 	void
 	set_up_taskfactory(){
-		using namespace basic::options;
-		using namespace basic::options::OptionKeys;
+		using namespace core::options;
+		using namespace core::options::OptionKeys;
 
 		using namespace core::pack::task;
 		using namespace core::pack::task::operation;
@@ -331,7 +331,7 @@ public:
 
 
 		//borrowing IGNC's typedefs to set up the group pairs
-		using namespace protocols::toolbox::pose_metric_calculators;
+		using namespace protocols::toolbox::PoseMetricCalculators;
 		InterGroupNeighborsCalculator::group_set groups;
 		//push back pairs of sets for the regions we need:
 		// E3hinge_self
@@ -357,13 +357,13 @@ public:
 
 		//make the calculator
 		std::string const calc_g("IGNC_g");
-		core::pose::metrics::CalculatorFactory::Instance().register_calculator( calc_g, new protocols::toolbox::pose_metric_calculators::InterGroupNeighborsCalculator(groups) );
+		core::pose::metrics::CalculatorFactory::Instance().register_calculator( calc_g, new protocols::toolbox::PoseMetricCalculators::InterGroupNeighborsCalculator(groups) );
 
 		//this is the constructor parameter for the TaskOperation - pairs of calculators and calculations to perform
 		utility::vector1< std::pair< std::string, std::string> > calcs_and_calcns;
 		calcs_and_calcns.push_back(std::make_pair(calc_g, "neighbors"));
 
-		using protocols::toolbox::task_operations::RestrictByCalculatorsOperation;
+		using protocols::toolbox::TaskOperations::RestrictByCalculatorsOperation;
 		task_factory_->push_back( new RestrictByCalculatorsOperation( calcs_and_calcns ) );
 
 		return;
@@ -376,7 +376,7 @@ public:
 		using core::id::AtomID;
 
 		//build the BoundFuncs we are going to use
-		using namespace basic::options;
+		using namespace core::options;
 		BoundFuncOP chargepair( new BoundFunc( 0, 3, option[OptionKeys::ubq_cst_sd].value(), "chargepair") );
 		BoundFuncOP hbond( new BoundFunc( 0, 3, option[OptionKeys::ubq_cst_sd].value(), "hbond") );
 
@@ -578,7 +578,7 @@ public:
 		MinMoverOP min_mover = new MinMover(
 																				movemap_,
 																				fullatom_scorefunction_,
-																				basic::options::option[ basic::options::OptionKeys::run::min_type ].value(),
+																				core::options::option[ core::options::OptionKeys::run::min_type ].value(),
 																				0.01,
 																				true /*use_nblist*/ );
 
@@ -598,8 +598,8 @@ public:
 																																											20.0)); //20 score units
 
 		//run loop
-		using basic::options::option;
-		using namespace basic::options::OptionKeys;
+		using core::options::option;
+		using namespace core::options::OptionKeys;
 		core::Size const applies = option[ cycles ].value(); //default 5
 		core::Size const repackcycles = option[ repack_cycles ].value();
 		TR << "   Current     Low    total cycles =" << applies << std::endl;
diff --git a/src/apps/pilot/sraman/RBSegMove_test.cc b/src/apps/pilot/sraman/RBSegMove_test.cc
index 331f306..559931a 100644
--- a/src/apps/pilot/sraman/RBSegMove_test.cc
+++ b/src/apps/pilot/sraman/RBSegMove_test.cc
@@ -54,6 +54,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -85,7 +86,7 @@ main( int argc, char * argv [] )
 	core::pose::Pose pose;
 	core::import_pose::pose_from_pdb( pose, option[ OptionKeys::RBSegmentRelax::input_pdb ]().name() );
 
-	protocols::loops::core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+	protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 
 	//HelixRegisterShiftMoverOP reg_shift( new protocols::moves::HelixRegisterShiftMover( 3,28 ) );
 	//	std::string function_tag("cen_std"),patch_tag("score4L");
diff --git a/src/apps/pilot/sraman/RBSegMove_test_viewer.cc b/src/apps/pilot/sraman/RBSegMove_test_viewer.cc
index 6de4354..90ade43 100644
--- a/src/apps/pilot/sraman/RBSegMove_test_viewer.cc
+++ b/src/apps/pilot/sraman/RBSegMove_test_viewer.cc
@@ -59,6 +59,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -88,7 +89,7 @@ RBSegmentRelax_test()
 	core::pose::Pose pose;
 	core::import_pose::pose_from_pdb( pose, option[ OptionKeys::RBSegmentRelax::input_pdb ]().name() );
 
-	protocols::loops::core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+	protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 
 	//HelixRegisterShiftMoverOP reg_shift( new protocols::moves::HelixRegisterShiftMover( 3,28 ) );
 	//	std::string function_tag("cen_std"),patch_tag("score4L");
diff --git a/src/apps/pilot/will/bpy.cc b/src/apps/pilot/will/bpy.cc
index 81c4d9e..0e29444 100644
--- a/src/apps/pilot/will/bpy.cc
+++ b/src/apps/pilot/will/bpy.cc
@@ -83,6 +83,7 @@
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 using core::Size;
@@ -115,7 +116,7 @@ struct PoseWrap {
 
 void switch_to_fa(PoseWrap & pw) {
 	core::pose::Pose const cen( pw.pose );
-	core::pose::switch_to_residue_type_set( pw.pose, core::chemical::FA_STANDARD );
+	protocols::toolbox::switch_to_residue_type_set( pw.pose, core::chemical::FA_STANDARD );
 	core::id::AtomID_Map<bool> missing;
 	core::pose::initalize_atomid_map(missing,pw.pose,false);
 	bool anymissing = false;
@@ -137,7 +138,7 @@ void switch_to_fa(PoseWrap & pw) {
 
 void switch_to_cen(PoseWrap & pw) {
 	core::pose::Pose const fa( pw.pose );
-	core::pose::switch_to_residue_type_set( pw.pose, core::chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( pw.pose, core::chemical::CENTROID );
 	core::id::AtomID_Map<bool> missing;
 	core::pose::initalize_atomid_map(missing,pw.pose,false);
 	bool anymissing = false;
diff --git a/src/apps/pilot/will/coiled_coil.cc b/src/apps/pilot/will/coiled_coil.cc
index db48495..4234ac8 100644
--- a/src/apps/pilot/will/coiled_coil.cc
+++ b/src/apps/pilot/will/coiled_coil.cc
@@ -61,6 +61,7 @@
 //Auto Headers
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 static basic::Tracer TR("coiled_coil");
@@ -1187,7 +1188,7 @@ main( int argc, char * argv [] )
 		cenpose = cc;
 
 		cc.remove_constraints();
-		core::pose::switch_to_residue_type_set( cc, core::chemical::FA_STANDARD );
+		protocols::toolbox::switch_to_residue_type_set( cc, core::chemical::FA_STANDARD );
 		// cc.dump_pdb("fa0.pdb");
 		// std::cerr << "fa0 " << (*sf2)(cc) << std::endl;
 		add_fa_cst(cc,p);
diff --git a/src/apps/pilot/will/coiled_coil_zn.cc b/src/apps/pilot/will/coiled_coil_zn.cc
index 1f292ca..fe9660f 100644
--- a/src/apps/pilot/will/coiled_coil_zn.cc
+++ b/src/apps/pilot/will/coiled_coil_zn.cc
@@ -62,6 +62,7 @@
 //Auto Headers
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -1173,7 +1174,7 @@ main( int argc, char * argv [] )
 		cenpose = cc;
 
 		cc.remove_constraints();
-		core::pose::switch_to_residue_type_set( cc, core::chemical::FA_STANDARD );
+		protocols::toolbox::switch_to_residue_type_set( cc, core::chemical::FA_STANDARD );
 		// cc.dump_pdb("fa0.pdb");
 		// std::cerr << "fa0 " << (*sf2)(cc) << std::endl;
 		add_fa_cst(cc,p);
diff --git a/src/apps/pilot/will/dubois.cc b/src/apps/pilot/will/dubois.cc
index 810b2eb..e641c11 100644
--- a/src/apps/pilot/will/dubois.cc
+++ b/src/apps/pilot/will/dubois.cc
@@ -67,6 +67,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 using numeric::conversions::radians;
@@ -84,13 +85,13 @@ using core::scoring::ScoreFunctionOP;
 using numeric::random::uniform;
 
 void switch_to_fa(core::pose::Pose & pose) {
-	core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+	protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 	pose.set_dof(core::id::DOF_ID(core::id::AtomID(6,2),core::id::PHI  ),0);
 	pose.set_dof(core::id::DOF_ID(core::id::AtomID(6,2),core::id::THETA),3.14159);
 }
 
 void switch_to_cen(core::pose::Pose & pose) {
-	core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 	pose.set_dof(core::id::DOF_ID(core::id::AtomID(6,2),core::id::PHI  ),0);
 	pose.set_dof(core::id::DOF_ID(core::id::AtomID(6,2),core::id::THETA),3.14159);
 }
diff --git a/src/apps/pilot/will/smhybrid.cc b/src/apps/pilot/will/smhybrid.cc
index c267af9..5613306 100644
--- a/src/apps/pilot/will/smhybrid.cc
+++ b/src/apps/pilot/will/smhybrid.cc
@@ -92,6 +92,7 @@
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -292,7 +293,7 @@ PoseWrap posewrap_from_command_line() {
 
 void switch_to_fa(PoseWrap & pw) {
 	core::pose::Pose const cen( pw.pose );
-	core::pose::switch_to_residue_type_set( pw.pose, core::chemical::FA_STANDARD );
+	protocols::toolbox::switch_to_residue_type_set( pw.pose, core::chemical::FA_STANDARD );
 	core::id::AtomID_Map<bool> missing;
 	core::pose::initialize_atomid_map(missing,pw.pose,false);
 	bool anymissing = false;
@@ -314,7 +315,7 @@ void switch_to_fa(PoseWrap & pw) {
 
 void switch_to_cen(PoseWrap & pw) {
 	core::pose::Pose const fa( pw.pose );
-	core::pose::switch_to_residue_type_set( pw.pose, core::chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( pw.pose, core::chemical::CENTROID );
 	core::id::AtomID_Map<bool> missing;
 	core::pose::initialize_atomid_map(missing,pw.pose,false);
 	bool anymissing = false;
diff --git a/src/apps/pilot/will/spiro.cc b/src/apps/pilot/will/spiro.cc
index acdc848..31683fc 100644
--- a/src/apps/pilot/will/spiro.cc
+++ b/src/apps/pilot/will/spiro.cc
@@ -76,6 +76,7 @@
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
 #include <core/scoring/constraints/Constraint.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 #include <utility/io/mpistream.hh>
 #include <ObjexxFCL/format.hh>
 
@@ -109,11 +110,11 @@ struct PoseWrap {
 };
 
 void switch_to_fa(PoseWrap & pw) {
-	core::pose::switch_to_residue_type_set( pw.pose, core::chemical::FA_STANDARD );
+	protocols::toolbox::switch_to_residue_type_set( pw.pose, core::chemical::FA_STANDARD );
 }
 
 void switch_to_cen(PoseWrap & pw) {
-	core::pose::switch_to_residue_type_set( pw.pose, core::chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( pw.pose, core::chemical::CENTROID );
 }
 
 void minimize(PoseWrap & pw, ScoreFunctionOP sf) {
diff --git a/src/core.src.settings b/src/core.src.settings
index db4f61a..b4f2474 100644
--- a/src/core.src.settings
+++ b/src/core.src.settings
@@ -273,7 +273,6 @@ sources = {
 		"PDBInfo",
                 "MiniPose",
                 "annotated_sequence",
-		"disulfide_util",
 	],
 
 	"core/pose/datacache" : [
@@ -499,7 +498,6 @@ sources = {
 		"KofNConstraint",
 		#"ConstraintForest",
 		"BigBinConstraint",
-		"BindingSiteConstraint",
 		"ConstraintIO",
 		"ResidueTypeConstraint",
 		"SquareWellFunc",
diff --git a/src/core/chemical/disulfide_util.cc b/src/core/chemical/disulfide_util.cc
deleted file mode 100644
index 7850041..0000000
--- a/src/core/chemical/disulfide_util.cc
+++ /dev/null
@@ -1,357 +0,0 @@
-// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
-// vi: set ts=2 sw=2 noet:
-//
-// This file is part of the Rosetta software suite and is made available under license.
-// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
-// (C) 199x-2009 Rosetta Commons participating institutions and developers.
-// For more information, see http://www.rosettacommons.org/.
-
-/// @file core/chemical/disulfide_util.cc
-/// @brief A collection of procedures for manipulating disulfide bonds
-/// @author Spencer Bliven <blivens@u.washington.edu>
-/// @date 4/30/2009
-
-// Unit Headers
-#include <core/chemical/disulfide_util.hh>
-
-// Project Headers
-// Package Headers
-#include <core/types.hh>
-#include <core/pose/Pose.hh>
-
-// AUTO-REMOVED #include <core/conformation/Interface.hh>
-#include <core/conformation/Conformation.hh>
-#include <core/conformation/Residue.hh>
-#include <core/conformation/ResidueFactory.hh>
-#include <core/conformation/util.hh>
-#include <core/chemical/ChemicalManager.hh>
-// AUTO-REMOVED
-#include <core/chemical/ResidueTypeSet.hh>
-
-#include <core/pack/task/PackerTask.hh>
-#include <core/pack/task/TaskFactory.hh>
-#include <core/pack/task/RotamerSampleOptions.hh>
-#include <core/pack/pack_rotamers.hh>
-#include <core/kinematics/MoveMap.hh>
-
-#include <core/scoring/ScoreFunction.hh>
-#include <core/scoring/ScoreFunctionFactory.hh>
-#include <core/optimization/AtomTreeMinimizer.hh>
-#include <core/optimization/MinimizerOptions.hh>
-
-#include <basic/Tracer.hh>
-
-// Utility Headers
-// AUTO-REMOVED #include <utility/vector1.hh>
-
-// C++ headers
-// AUTO-REMOVED #include <utility>
-
-//Auto Headers
-#include <core/chemical/VariantType.hh>
-
-
-namespace core {
-namespace chemical {
-
-using namespace core;
-using namespace std;
-
-using utility::vector1;
-using core::pose::Pose;
-using core::pose::PoseOP;
-using namespace core::conformation;
-using core::pack::task::PackerTaskOP;
-using core::scoring::ScoreFunctionOP;
-using core::kinematics::MoveMap;
-using core::kinematics::MoveMapOP;
-static basic::Tracer TR( "core.chemical.disulfide_util" );
-
-
-/// @brief Introduce cysteines at the specified location and define a
-///  disulfide bond between them.
-/// @details Does not do the repacking & minimization required to place the
-///  disulfide correctly.
-void form_disulfide(Pose & pose, Size lower_res, Size upper_res)
-{
-	// Verify we're dealing with a FA pose
-	runtime_assert( pose.is_fullatom() );
-
-	ResidueTypeSetCAP restype_set =
-		ChemicalManager::get_instance()->residue_type_set( FA_STANDARD );
-
-	// Break existing disulfide bonds to lower
-	if( pose.residue(lower_res).aa() == chemical::aa_cys &&
-			pose.residue( lower_res ).has_variant_type( chemical::DISULFIDE ) &&
-			pose.residue_type( lower_res ).has_atom_name( "SG" ) // full atom residue
-			)
-	{
-		Size const connect_atom( pose.residue( lower_res ).atom_index( "SG" ) );
-		Size other_res( 0 );
-		Size conn(0);
-		for ( conn = pose.residue( lower_res ).type().n_residue_connections(); conn >= 1; --conn ) {
-			if( Size( pose.residue(lower_res).type().residue_connection(conn).atomno() ) == connect_atom ) {
-				other_res = pose.residue( lower_res ).connect_map( conn ).resid();
-				break;
-			}
-		}
-		if ( other_res == 0 ) {
-			TR.Error << "Error: Residue " << lower_res << " was disulfide bonded but had no partner" << std::endl;
-			utility_exit();
-		}
-
-		if(other_res == upper_res) {
-			// Already a disulfide bond
-			runtime_assert_msg(pose.residue( upper_res ).connect_map( conn ).resid() == lower_res,
-				"Error: Disulfide bond wasn't reciprical");
-			return;
-		}
-
-		// Break the disulfide bond to upper_res
-		bool result = change_cys_state( other_res, "CYS", pose.conformation() );
-		runtime_assert_msg(result,"Error converting CYD->CYS");
-	}
-	else {
-		ResidueOP lower_cyd = ResidueFactory::create_residue(
-			restype_set->name_map("CYD"), pose.residue(lower_res),
-			pose.conformation());
-		copy_residue_coordinates_and_rebuild_missing_atoms(
-			pose.residue(lower_res), *lower_cyd, pose.conformation() );
-		pose.replace_residue(lower_res, *lower_cyd, false /*backbone already oriented*/);
-	}
-	// Break existing disulfide bonds to upper
-	if( pose.residue(upper_res).aa() == chemical::aa_cys &&
-			pose.residue( upper_res ).has_variant_type( chemical::DISULFIDE ) &&
-			pose.residue_type( upper_res ).has_atom_name( "SG" ) // full atom residue
-			)
-	{
-		Size const connect_atom( pose.residue( upper_res ).atom_index( "SG" ) );
-		Size other_res( 0 );
-		Size conn(0);
-		for ( conn = pose.residue( upper_res ).type().n_residue_connections(); conn >= 1; --conn ) {
-			if( Size( pose.residue(upper_res).type().residue_connection(conn).atomno() ) == connect_atom ) {
-				other_res = pose.residue( upper_res ).connect_map( conn ).resid();
-				break;
-			}
-		}
-		if ( other_res == 0 ) {
-			TR.Warning << "Warning: Residue " << upper_res << " was disulfide bonded but had no partner" << std::endl;
-			utility_exit();
-		}
-
-		// Break the disulfide bond to lower_res
-		bool result = change_cys_state( other_res, "CYS", pose.conformation());
-		runtime_assert_msg(result,"Error converting CYD->CYS");
-	}
-	else {
-		ResidueOP upper_cyd = ResidueFactory::create_residue(
-			restype_set->name_map("CYD"), pose.residue(upper_res),
-			pose.conformation());
-		copy_residue_coordinates_and_rebuild_missing_atoms(
-			pose.residue(upper_res), *upper_cyd, pose.conformation() );
-		pose.replace_residue(upper_res, *upper_cyd, false /*backbone already oriented*/);
-	}
-
-	// Both residues are now CYD
-	runtime_assert(pose.residue(lower_res).name() == "CYD" && pose.residue(upper_res).name() == "CYD" );
-
-	//form the bond between the two residues
-	pose.conformation().declare_chemical_bond(lower_res,"SG",upper_res,"SG");
-
-}
-
-/// @details A convenience function for calling \c rebuild_disulfide() with
-///  only a single disulfide bond
-void rebuild_disulfide( Pose & pose, Size lower_res, Size upper_res,
-		PackerTaskOP packer_task, ScoreFunctionOP packer_score,
-		MoveMapOP mm, ScoreFunctionOP minimizer_score )
-{
-	vector1< pair<Size,Size> > disulfides;
-	disulfides.push_back(std::make_pair(lower_res,upper_res));
-	rebuild_disulfide(pose, disulfides, packer_task, packer_score, mm, minimizer_score);
-}
-
-
-/// @details
-/// @pre The two residues specified should already be cysteines with a bond
-///  defined between the SG atoms. This can be accomplished by first calling
-///  form_disulfide().
-///
-///  To provide the most flexibility, this function does not restrict
-///  the degrees of freedom in the repacking and minimization steps. This is
-///  needed in some cases where the backbone position is not optimal for making
-///  a disulfide bond. However, if this function needs to be reasonably fast
-///  you should prevent repacking on all residues except the two targets.
-///
-/// @param pose[in,out] The pose to modify with a disulfides
-/// @param lower_res[in] The first residue of the disulfide
-/// @param upper_res[in] The second residue of the disulfide
-/// @param packer_task[in] A task to control repacking. Defaults to repacking
-///  lower_res \& upper_res if ommitted or NULL.
-/// @param packer_score[in] A scoring function to use while repacking. Defaults
-///  to score12 if ommitted or NULL.
-/// @param mm[in] A MoveMap to control minimization. Defaults to full degrees
-///  of freedom if ommitted or NULL.
-/// @param minimizer_score[in] The score to use for minimization. Defaults to
-///  packer_score if ommitted or NULL.
-void rebuild_disulfide( core::pose::Pose & pose,
-	utility::vector1<std::pair<core::Size, core::Size> > disulfides,
-	core::pack::task::PackerTaskOP packer_task,
-	core::scoring::ScoreFunctionOP packer_score,
-	core::kinematics::MoveMapOP mm,
-	core::scoring::ScoreFunctionOP minimizer_score )
-//void rebuild_disulfide( Pose & pose, vector1<pair<Size, Size> > const& disulfides,
-//		PackerTaskOP packer_task, ScoreFunctionOP packer_score,
-//		MoveMapOP mm, ScoreFunctionOP minimizer_score )
-{
-	// Quick lookup of whether a residue is a disulfide or not
-	vector1<bool> is_disulf(pose.total_residue(), false);
-
-	for(vector1<pair<Size, Size> >::const_iterator
-			disulf(disulfides.begin()), end_disulf(disulfides.end());
-			disulf != end_disulf; ++disulf)
-	{
-		is_disulf[disulf->first] = true;
-		is_disulf[disulf->second] = true;
-
-		// Verify precondition
-		if( ! is_disulfide_bond(pose, disulf->first, disulf->second) ) {
-			TR.Error << "Disulfide bond required between " << disulf->first
-				<< " and " << disulf->second << "." << std::endl;
-			utility_exit();
-		}
-	}
-
-	// Set up any NULL parameters
-	if( !packer_task ) {
-		packer_task = core::pack::task::TaskFactory::create_packer_task( pose );
-		packer_task->initialize_from_command_line().or_include_current( true );
-		packer_task->restrict_to_repacking();
-
-		// Restrict repacking to the targets
-		for( Size i(1); i <= pose.total_residue(); ++i )
-		{
-			if( !is_disulf[i] ) {
-				packer_task->nonconst_residue_task(i).prevent_repacking();
-			}
-		}
-	}
-	if( !packer_score ) {
-		packer_score = scoring::getScoreFunction();
-	}
-	if( !mm ) {
-		mm = MoveMapOP(new MoveMap);
-		mm->set_bb( true );
-		mm->set_chi( true );
-	}
-	if( !minimizer_score ) {
-		minimizer_score = packer_score;
-	}
-
-	// Extend rotamers for the disulfide
-	for(vector1<pair<Size, Size> >::const_iterator
-		disulf(disulfides.begin()), end_disulf(disulfides.end());
-		disulf != end_disulf; ++disulf)
-	{
-		packer_task->nonconst_residue_task(disulf->first).and_extrachi_cutoff( 0 );
-		packer_task->nonconst_residue_task(disulf->second).and_extrachi_cutoff( 0 );
-		packer_task->nonconst_residue_task(disulf->first).or_ex1_sample_level(
-			pack::task::EX_SIX_QUARTER_STEP_STDDEVS);
-		packer_task->nonconst_residue_task(disulf->second).or_ex1_sample_level(
-			pack::task::EX_SIX_QUARTER_STEP_STDDEVS);
-	}
-
-	// REPACK
-	(*packer_score)( pose ); // structure must be scored before rotamer_trials can be called
-	pack::pack_rotamers(pose, *packer_score, packer_task );
-
-	using namespace core::optimization;
-	AtomTreeMinimizer().run( pose, *mm, *minimizer_score,
-			MinimizerOptions( "dfpmin_armijo_nonmonotone", 0.01, true/*nblist*/, false/*deriv_check*/ ) );
-
-	// update score
-	pose.update_residue_neighbors();
-	(*minimizer_score)( pose );
-
-}
-
-/// @brief Find whether there is a disulfide defined between two residues
-///
-/// @details We define a disulfide to exist between a pair of residues iff
-///  -# They are both cysteines
-///  -# They are bonded by their sidechains
-bool
-is_disulfide_bond( pose::Pose const& pose, Size residueA_pos, Size residueB_pos)
-{
-	Residue const& A = pose.residue(residueA_pos);
-	Residue const& B = pose.residue(residueB_pos);
-
-	if( !A.is_protein() || !B.is_protein() )
-		return false;
-
-	//both Cys or CysD
-	if( A.type().name1() != 'C' || B.type().name1() != 'C' )
-		return false;
-
-	//bonded
-	Size a_connect_atom;
-	if( A.type().has_atom_name( "SG" ) )
-		a_connect_atom = A.atom_index( "SG" );
-	else {
-		runtime_assert( A.type().has_atom_name( "CEN" ) ); //should be fa or centroid
-		a_connect_atom = A.atom_index( "CEN" );
-	}
-	for ( Size connection = A.type().n_residue_connections(); connection >= 1; --connection ) {
-		//check if A bonded to B
-		if ( (Size) A.type().residue_connection( connection ).atomno() == a_connect_atom && //bond to sg, not the backbone
-				A.connect_map( connection ).resid() == residueB_pos ) { //bonded to B
-			return true;
-		}
-	}
-
-	return false;
-}
-
-/// @brief Generate a list of all disulfide bonds in the pose
-void disulfide_bonds( pose::Pose const& pose, vector1< pair<Size,Size> > & disulfides )
-{
-	for( Size i=1; i<= pose.total_residue(); ++i)
-	{
-		Residue const& res(pose.residue(i));
-
-		// Skip things besides CYD
-		if( !(res.aa() == aa_cys && res.has_variant_type(chemical::DISULFIDE) ))
-			continue;
-		Size connect_atom( 0);
-		if( res.type().has_atom_name( "SG" ))
-			connect_atom = res.atom_index( "SG" );
-		else if( res.type().has_atom_name( "CEN" ))
-			connect_atom = res.atom_index( "CEN" );
-		else {
-			TR.Warning << "Warning: unable to establish which atom to use for the disulfide to residue "
-				<< i << std::endl;
-			continue;
-		}
-
-		Size other_res(0);
-		Size conn;
-		for( conn = pose.residue( i ).type().n_residue_connections(); conn >= 1; --conn ) {
-			if( Size( pose.residue( i ).type().residue_connection(conn).atomno() ) == connect_atom ) {
-				other_res = pose.residue( i ).connect_map( conn ).resid();
-				break;
-			}
-		}
-		if ( other_res == 0 ) {
-			TR.Error << "Error: Residue " << i << " was disulfide bonded but had no partner" << std::endl;
-			utility_exit();
-		}
-
-		// Output the pair once
-		if( i < other_res ) {
-			disulfides.push_back( std::make_pair(i, other_res) );
-		}
-	}
-}
-
-} // protein_interface_design
-} // devel
diff --git a/src/core/chemical/disulfide_util.hh b/src/core/chemical/disulfide_util.hh
deleted file mode 100644
index 43c6fac..0000000
--- a/src/core/chemical/disulfide_util.hh
+++ /dev/null
@@ -1,87 +0,0 @@
-// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
-// vi: set ts=2 sw=2 noet:
-//
-// This file is part of the Rosetta software suite and is made available under license.
-// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
-// (C) 199x-2009 Rosetta Commons participating institutions and developers.
-// For more information, see http://www.rosettacommons.org/.
-
-/// @file core/chemical/disulfide_util.hh
-/// @brief A collection of procedures for manipulating disulfide bonds
-/// @author Spencer Bliven <blivens@u.washington.edu>
-/// @date 4/30/2009
-
-#ifndef INCLUDED_core_chemical_disulfide_util_HH
-#define INCLUDED_core_chemical_disulfide_util_HH
-
-
-// Project Headers
-// AUTO-REMOVED #include <core/pack/task/PackerTask.hh>
-// AUTO-REMOVED #include <core/kinematics/MoveMap.hh>
-// AUTO-REMOVED #include <core/scoring/ScoreFunction.hh>
-#include <core/types.hh>
-// AUTO-REMOVED #include <core/pose/Pose.hh>
-
-// Utility headers
-// AUTO-REMOVED #include <utility/vector1.hh>
-
-// C++ headers
-// AUTO-REMOVED #include <utility>
-
-//Auto Headers
-#include <core/conformation/Conformation.fwd.hh>
-#include <core/kinematics/MoveMap.fwd.hh>
-#include <core/pack/task/PackerTask.fwd.hh>
-#include <core/pose/Pose.fwd.hh>
-#include <core/scoring/ScoreFunction.fwd.hh>
-#include <utility/vector1.fwd.hh>
-#include <iostream>
-#ifdef __clang__
-#include <core/kinematics/MoveMap.hh>
-#include <core/pack/task/PackerTask.hh>
-#include <core/scoring/ScoreFunction.hh>
-#endif
-
-
-// Unit headers
-
-namespace core {
-namespace chemical {
-
-/// @brief Introduce cysteines at the specified location and define a
-///  disulfide bond between them.
-/// @details Does not do the repacking & minimization required to place the
-///   disulfide correctly.
-void form_disulfide(core::pose::Pose & pose, core::Size lower_res, core::Size upper_res);
-
-/// @brief Rebuild a pair of cysteines (and possibly surrounding residues) so
-///  that they form a near-ideal disulfide bond
-void rebuild_disulfide( core::pose::Pose & pose,
-	core::Size lower_res, core::Size upper_res,
-	core::pack::task::PackerTaskOP packer_task = 0,
-	core::scoring::ScoreFunctionOP packer_score = 0,
-	core::kinematics::MoveMapOP mm = 0,
-	core::scoring::ScoreFunctionOP minimizer_score = 0 );
-
-/// @brief Rebuild a number of pairs of cysteines (and possibly surrounding
-///  residues) so that they form near-ideal disulfide bonds
-void rebuild_disulfide( core::pose::Pose & pose,
-	utility::vector1<std::pair<core::Size, core::Size> > disulfides,
-	core::pack::task::PackerTaskOP packer_task = 0,
-	core::scoring::ScoreFunctionOP packer_score = 0,
-	core::kinematics::MoveMapOP mm = 0,
-	core::scoring::ScoreFunctionOP minimizer_score = 0 );
-
-/// @brief Find whether there is a disulfide defined between two residues
-bool is_disulfide_bond( core::pose::Pose const& pose,
-	core::Size residueA_pos, core::Size residueB_pos);
-
-/// @brief Generate a list of all disulfide bonds in the pose
-void disulfide_bonds( core::pose::Pose const& pose,
-	utility::vector1< std::pair<core::Size,core::Size> > & disulfides );
-
-} // chemical
-} // core
-
-#endif //INCLUDED_core_chemical_disulfide_util_HH
-
diff --git a/src/core/chemical/util.cc b/src/core/chemical/util.cc
index df78210..a023614 100644
--- a/src/core/chemical/util.cc
+++ b/src/core/chemical/util.cc
@@ -21,7 +21,6 @@
 //#include <core/chemical/ResidueType.hh>
 //#include <core/chemical/VariantType.hh>
 #include <core/chemical/ChemicalManager.hh>
-#include <core/pose/disulfide_util.hh>
 
 // Project Headers
 #include <core/types.hh>
diff --git a/src/core/conformation/Conformation.cc b/src/core/conformation/Conformation.cc
index 04f3b4e..f3c9896 100644
--- a/src/core/conformation/Conformation.cc
+++ b/src/core/conformation/Conformation.cc
@@ -36,8 +36,6 @@
 #include <core/chemical/ResidueTypeSet.hh>
 #include <core/chemical/VariantType.hh>
 
-#include <core/pose/disulfide_util.hh>
-
 #include <basic/Tracer.hh>
 #include <core/util/prof.hh>
 #include <core/util/basic.hh>
diff --git a/src/core/init.cc b/src/core/init.cc
index 5d3e248..4a8399a 100644
--- a/src/core/init.cc
+++ b/src/core/init.cc
@@ -310,7 +310,6 @@ static ConstraintRegistrator< core::scoring::constraints::AmbiguousNMRDistanceCo
 static ConstraintRegistrator< core::scoring::constraints::AngleConstraintCreator > AngleConstraintCreator_registrator;
 static ConstraintRegistrator< core::scoring::constraints::AtomPairConstraintCreator > AtomPairConstraintCreator_registrator;
 static ConstraintRegistrator< core::scoring::constraints::BigBinConstraintCreator > BigBinConstraintCreator_registrator;
-static ConstraintRegistrator< core::scoring::constraints::BindingSiteConstraintCreator > BindingSiteConstraintCreator_registrator;
 static ConstraintRegistrator< core::scoring::constraints::CoordinateConstraintCreator > CoordinateConstraintCreator_registrator;
 static ConstraintRegistrator< core::scoring::constraints::DihedralConstraintCreator > DihedralConstraintCreator_registrator;
 static ConstraintRegistrator< core::scoring::constraints::KofNConstraintCreator > KofNConstraintCreator_registrator;
diff --git a/src/core/pose/disulfide_util.cc b/src/core/pose/disulfide_util.cc
deleted file mode 100644
index f18a9fd..0000000
--- a/src/core/pose/disulfide_util.cc
+++ /dev/null
@@ -1,182 +0,0 @@
-// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
-// vi: set ts=2 sw=2 noet:
-//
-// This file is part of the Rosetta software suite and is made available under license.
-// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
-// (C) 199x-2009 Rosetta Commons participating institutions and developers.
-// For more information, see http://www.rosettacommons.org/.
-
-/// @file protocols/toolbox/disulfide_util.cc
-/// @brief A collection of procedures for manipulating disulfide bonds
-/// @author Spencer Bliven <blivens@u.washington.edu>
-/// @date 4/30/2009
-
-// Unit Headers
-#include <core/pose/disulfide_util.hh>
-#include <core/conformation/util.hh>
-
-// Project Headers
-// Package Headers
-#include <core/types.hh>
-#include <core/pose/Pose.hh>
-
-#include <core/conformation/Conformation.hh>
-#include <core/conformation/util.hh>
-#include <core/conformation/Residue.hh>
-#include <core/conformation/ResidueFactory.hh>
-#include <core/conformation/util.hh>
-
-#include <core/chemical/ChemicalManager.hh>
-#include <core/chemical/ResidueTypeSet.hh>
-#include <core/chemical/VariantType.hh>
-
-#include <core/pack/task/PackerTask.hh>
-#include <core/pack/task/TaskFactory.hh>
-#include <core/pack/task/RotamerSampleOptions.hh>
-#include <core/pack/pack_rotamers.hh>
-
-#include <core/kinematics/MoveMap.hh>
-
-#include <core/scoring/ScoreFunction.hh>
-#include <core/scoring/ScoreFunctionFactory.hh>
-#include <core/optimization/AtomTreeMinimizer.hh>
-#include <core/optimization/MinimizerOptions.hh>
-
-#include <basic/Tracer.hh>
-
-namespace core {
-namespace pose {
-
-using namespace core;
-using namespace std;
-
-using utility::vector1;
-using core::pose::Pose;
-using core::pose::PoseOP;
-using namespace core::conformation;
-using core::pack::task::PackerTaskOP;
-using core::scoring::ScoreFunctionOP;
-using core::kinematics::MoveMap;
-using core::kinematics::MoveMapOP;
-static basic::Tracer TR( "core.chemical.disulfide_util" );
-
-
-
-/// @details A convenience function for calling \c core::pose::rebuild_disulfide() with
-///  only a single disulfide bond
-void
-rebuild_disulfide( Pose & pose, Size lower_res, Size upper_res,
-		PackerTaskOP packer_task, ScoreFunctionOP packer_score,
-		MoveMapOP mm, ScoreFunctionOP minimizer_score )
-{
-	vector1< pair<Size,Size> > disulfides;
-	disulfides.push_back(std::make_pair(lower_res,upper_res));
-	core::pose::rebuild_disulfide(pose, disulfides, packer_task, packer_score, mm, minimizer_score);
-}
-
-
-/// @details
-/// @pre The two residues specified should already be cysteines with a bond
-///  defined between the SG atoms. This can be accomplished by first calling
-///  core::conformation::form_disulfide().
-///
-///  To provide the most flexibility, this function does not restrict
-///  the degrees of freedom in the repacking and minimization steps. This is
-///  needed in some cases where the backbone position is not optimal for making
-///  a disulfide bond. However, if this function needs to be reasonably fast
-///  you should prevent repacking on all residues except the two targets.
-///
-/// @param pose[in,out] The pose to modify with a disulfides
-/// @param lower_res[in] The first residue of the disulfide
-/// @param upper_res[in] The second residue of the disulfide
-/// @param packer_task[in] A task to control repacking. Defaults to repacking
-///  lower_res \& upper_res if ommitted or NULL.
-/// @param packer_score[in] A scoring function to use while repacking. Defaults
-///  to score12 if ommitted or NULL.
-/// @param mm[in] A MoveMap to control minimization. Defaults to full degrees
-///  of freedom if ommitted or NULL.
-/// @param minimizer_score[in] The score to use for minimization. Defaults to
-///  packer_score if ommitted or NULL.
-void
-rebuild_disulfide( core::pose::Pose & pose,
-	utility::vector1<std::pair<core::Size, core::Size> > disulfides,
-	core::pack::task::PackerTaskOP packer_task,
-	core::scoring::ScoreFunctionOP packer_score,
-	core::kinematics::MoveMapOP mm,
-	core::scoring::ScoreFunctionOP minimizer_score )
-//void core::pose::rebuild_disulfide( Pose & pose, vector1<pair<Size, Size> > const& disulfides,
-//		PackerTaskOP packer_task, ScoreFunctionOP packer_score,
-//		MoveMapOP mm, ScoreFunctionOP minimizer_score )
-{
-	// Quick lookup of whether a residue is a disulfide or not
-	vector1<bool> is_disulf(pose.total_residue(), false);
-
-	for(vector1<pair<Size, Size> >::const_iterator
-			disulf(disulfides.begin()), end_disulf(disulfides.end());
-			disulf != end_disulf; ++disulf)
-	{
-		is_disulf[disulf->first] = true;
-		is_disulf[disulf->second] = true;
-
-		// Verify precondition
-		if( ! core::conformation::is_disulfide_bond(pose.conformation(), disulf->first, disulf->second) ) {
-			TR.Error << "Disulfide bond required between " << disulf->first
-				<< " and " << disulf->second << "." << std::endl;
-			utility_exit();
-		}
-	}
-
-	// Set up any NULL parameters
-	if( !packer_task ) {
-		packer_task = core::pack::task::TaskFactory::create_packer_task( pose );
-		packer_task->initialize_from_command_line().or_include_current( true );
-		packer_task->restrict_to_repacking();
-
-		// Restrict repacking to the targets
-		for( Size i(1); i <= pose.total_residue(); ++i )
-		{
-			if( !is_disulf[i] ) {
-				packer_task->nonconst_residue_task(i).prevent_repacking();
-			}
-		}
-	}
-	if( !packer_score ) {
-		packer_score = scoring::getScoreFunction();
-	}
-	if( !mm ) {
-		mm = MoveMapOP(new MoveMap);
-		mm->set_bb( true );
-		mm->set_chi( true );
-	}
-	if( !minimizer_score ) {
-		minimizer_score = packer_score;
-	}
-
-	// Extend rotamers for the disulfide
-	for(vector1<pair<Size, Size> >::const_iterator
-		disulf(disulfides.begin()), end_disulf(disulfides.end());
-		disulf != end_disulf; ++disulf)
-	{
-		packer_task->nonconst_residue_task(disulf->first).and_extrachi_cutoff( 0 );
-		packer_task->nonconst_residue_task(disulf->second).and_extrachi_cutoff( 0 );
-		packer_task->nonconst_residue_task(disulf->first).or_ex1_sample_level(
-			pack::task::EX_SIX_QUARTER_STEP_STDDEVS);
-		packer_task->nonconst_residue_task(disulf->second).or_ex1_sample_level(
-			pack::task::EX_SIX_QUARTER_STEP_STDDEVS);
-	}
-
-	// REPACK
-	(*packer_score)(pose); // structure must be scored before rotamer_trials can be called
-	pack::pack_rotamers(pose, *packer_score, packer_task );
-
-	using namespace core::optimization;
-	AtomTreeMinimizer().run( pose, *mm, *minimizer_score, MinimizerOptions( "dfpmin_armijo_nonmonotone", 0.01, true/*nblist*/, false/*deriv_check*/ ) );
-
-	// update score
-	pose.update_residue_neighbors();
-	(*minimizer_score)( pose );
-
-}
-
-} // pose
-} // core
diff --git a/src/core/pose/disulfide_util.hh b/src/core/pose/disulfide_util.hh
deleted file mode 100644
index 6df5606..0000000
--- a/src/core/pose/disulfide_util.hh
+++ /dev/null
@@ -1,73 +0,0 @@
-// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
-// vi: set ts=2 sw=2 noet:
-//
-// This file is part of the Rosetta software suite and is made available under license.
-// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
-// (C) 199x-2009 Rosetta Commons participating institutions and developers.
-// For more information, see http://www.rosettacommons.org/.
-
-/// @file protocols/toolbox/disulfide_util.hh
-/// @brief A collection of procedures for manipulating disulfide bonds
-/// @author Spencer Bliven <blivens@u.washington.edu>
-/// @date 4/30/2009
-
-#ifndef INCLUDED_core_pose_disulfide_util_HH
-#define INCLUDED_core_pose_disulfide_util_HH
-
-
-// Project Headers
-// AUTO-REMOVED #include <core/pack/task/PackerTask.hh>
-// AUTO-REMOVED #include <core/kinematics/MoveMap.hh>
-// AUTO-REMOVED #include <core/scoring/ScoreFunction.hh>
-#include <core/types.hh>
-// AUTO-REMOVED #include <core/pose/Pose.hh>
-
-// Utility headers
-// AUTO-REMOVED #include <utility/vector1.hh>
-
-// C++ headers
-// AUTO-REMOVED #include <utility>
-
-//Auto Headers
-#include <core/conformation/Conformation.fwd.hh>
-#include <core/kinematics/MoveMap.fwd.hh>
-#include <core/pack/task/PackerTask.fwd.hh>
-#include <core/pose/Pose.fwd.hh>
-#include <core/scoring/ScoreFunction.fwd.hh>
-#include <utility/vector1.fwd.hh>
-#include <iostream>
-#ifdef __clang__
-#include <core/kinematics/MoveMap.hh>
-#include <core/pack/task/PackerTask.hh>
-#include <core/scoring/ScoreFunction.hh>
-#endif
-
-
-// Unit headers
-
-namespace core {
-namespace pose {
-
-/// @brief Rebuild a pair of cysteines (and possibly surrounding residues) so
-///  that they form a near-ideal disulfide bond
-void rebuild_disulfide( core::pose::Pose & pose,
-	core::Size lower_res, core::Size upper_res,
-	core::pack::task::PackerTaskOP packer_task = 0,
-	core::scoring::ScoreFunctionOP packer_score = 0,
-	core::kinematics::MoveMapOP mm = 0,
-	core::scoring::ScoreFunctionOP minimizer_score = 0 );
-
-/// @brief Rebuild a number of pairs of cysteines (and possibly surrounding
-///  residues) so that they form near-ideal disulfide bonds
-void rebuild_disulfide( core::pose::Pose & pose,
-	utility::vector1<std::pair<core::Size, core::Size> > disulfides,
-	core::pack::task::PackerTaskOP packer_task = 0,
-	core::scoring::ScoreFunctionOP packer_score = 0,
-	core::kinematics::MoveMapOP mm = 0,
-	core::scoring::ScoreFunctionOP minimizer_score = 0 );
-
-} // pose
-} // core
-
-#endif //INCLUDED_core_pose_disulfide_util_HH
-
diff --git a/src/core/pose/util.cc b/src/core/pose/util.cc
index 05277f5..c47e48f 100644
--- a/src/core/pose/util.cc
+++ b/src/core/pose/util.cc
@@ -23,7 +23,6 @@
 #include <core/pose/Pose.hh>
 #include <core/pose/MiniPose.hh>
 #include <core/pose/datacache/CacheableDataType.hh>
-#include <core/pose/disulfide_util.hh>
 #include <core/conformation/Conformation.hh>
 #include <core/conformation/ResidueFactory.hh>
 #include <core/conformation/util.hh>
@@ -34,7 +33,6 @@
 #include <core/id/NamedStubID.hh>
 #include <core/id/NamedAtomID.hh>
 #include <core/chemical/VariantType.hh>
-//#include <core/pose/disulfide_util.hh>
 #include <core/kinematics/MoveMap.hh>
 #include <core/util/datacache/BasicDataCache.hh>
 #include <core/scoring/ScoreType.hh>
@@ -65,6 +63,10 @@
 #include <basic/options/keys/in.OptionKeys.gen.hh>
 #include <basic/options/keys/run.OptionKeys.gen.hh>
 
+//Auto Headers
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
+
+
 namespace core {
 namespace pose {
 
@@ -1510,147 +1512,6 @@ remove_upper_terminus_type_from_pose_residue(
 	core::pose::remove_variant_type_from_pose_residue( pose, chemical::UPPER_TERMINUS, seqpos );
 }
 
-////////////////////////////////////////////////////////////////////////////////////////////////////////////
-///@details the function allows a pose to use a different residue_type_set to represent all its residues,
-///such as from fullatom residues to centroid residues, or vice versa. During the switch, corresponding atoms
-///will be copied. Redundant atoms will be removed (in case from fullatom to centroid) and missing atoms will be
-///built by ideal geometry (in the case from centroid to fullatom).
-void
-switch_to_residue_type_set(
-	pose::Pose & pose,
-	std::string const & type_set_name,
-	bool allow_sloppy_match
-	)
-{
-	using namespace core::chemical;
-	using namespace core::conformation;
-	using namespace std;
-	using utility::vector1;
-
-	//SML 04/06/09
-	//Energies object is not properly "aware" of typeset changes, and can attempt to score your pose with an incompatible
-	//scorefunction if you go FA->CEN (or vice versa) and access the Energies without rescoring.
-	//So, we'll eject the Energies to be safe!
-	pose.energies().clear();
-
-
-	// retrieve proper residue_type_set
-	chemical::ResidueTypeSetCAP target_residue_type_set( chemical::ChemicalManager::get_instance()->residue_type_set( type_set_name ) );
-	// loop each position and find new type that matches from the new type set
-	for ( Size i=1; i<= pose.total_residue(); ++i ) {
-		conformation::Residue const & rsd( pose.residue(i) );
-		// in future we may have a conformation using mixed type set, so check this by residue
-		std::string const & current_type_set_name ( rsd.type().residue_type_set().name() ); // database_directory() );
-		if ( current_type_set_name == type_set_name ) {
-			TR.Warning << "switch_to_residue_type_set: residue " << i << " already in " << type_set_name
-			<< " residue_type_set" << std::endl;
-			continue;
-		}
-
-		// get all residue types with same AA
-
-		conformation::ResidueOP new_rsd( 0 );
-		if( ( rsd.aa() == aa_unk ) || ( rsd.name().substr(0,5) == "HIS_D" ) ){
-			// ligand or metal ions are all defined as "UNK" AA, so check a rsdtype with same name
-			// for HIS_D tautomer, we want to keep its tautomer state
-			chemical::ResidueTypeCAPs const & rsd_types( target_residue_type_set->name3_map( rsd.name3() ) );
-			for (Size j=1; j<=rsd_types.size(); ++j ) {
-				chemical::ResidueType const & new_rsd_type( *rsd_types[j] );
-				if ( rsd.type().name() == new_rsd_type.name() ) {
-					new_rsd = conformation::ResidueFactory::create_residue( new_rsd_type, rsd, pose.conformation() );
-					break;
-				}
-			}
-		} else  {
-			// for a normal AA/DNA/RNA residue, now look for a rsdtype with same variants
-			chemical::ResidueTypeCAPs const & rsd_types( target_residue_type_set->name3_map( rsd.name().substr(0,3) ) );
-			for ( Size j=1; j<= rsd_types.size(); ++j ) {
-				chemical::ResidueType const & new_rsd_type( *rsd_types[j] );
-				if ( rsd.type().variants_match( new_rsd_type ) ) {
-					new_rsd = conformation::ResidueFactory::create_residue( new_rsd_type, rsd, pose.conformation() );
-					break;
-				}
-			}
-			if ( allow_sloppy_match ){
-				if ( ! new_rsd ) {
-					TR.Warning << "Did not find perfect match for residue: "  << rsd.name()
-					<< "at position " << i << ". Trying to find acceptable match. " << std::endl;
-					for ( Size j=1; j<= rsd_types.size(); ++j ) {
-						chemical::ResidueType const & new_rsd_type( *rsd_types[j] );
-						if ( rsd.type().name3()  == new_rsd_type.name3()  ) {
-							new_rsd = conformation::ResidueFactory::create_residue( new_rsd_type, rsd, pose.conformation() );
-							break;
-						}
-					}
-					if (  new_rsd ) {
-						TR.Warning << "Found an acceptable match: " << rsd.type().name() << " --> " << new_rsd->name() << std::endl;
-					}
-				}
-			}
-		}
-
-		if ( ! new_rsd ) {
-			std::cerr << pose.sequence() << std::endl;
-			std::cerr  << "can not find a residue type that matches the residue " << rsd.name()
-			<< "at position " << i << std::endl;
-			utility_exit_with_message( "core::pose::switch_to_residue_type_set fails\n" );
-		}
-		// switch to corresponding residue type in the new set.
-		if ( !rsd.is_protein() ) {
-			// rethink this logic, phil
-			TR.Debug << "trying to preserve existing coords for non-protein residue: " << rsd.seqpos() << ' ' << rsd.name() << std::endl;
-			core::conformation::copy_residue_coordinates_and_rebuild_missing_atoms( rsd, *new_rsd, pose.conformation() );
-		}
-		pose.replace_residue( i, *new_rsd, false );
-	}
-
-	// After a CEN->FA transition, rebuild the disulfides
-	if(pose.is_fullatom() && basic::options::option[ basic::options::OptionKeys::run::rebuild_disulf ]() ) {
-		vector1<pair<Size,Size> > disulfides;
-		core::conformation::disulfide_bonds(pose.conformation(), disulfides);
-		if( disulfides.size() > 0 ) {
-			// Setup Packer & Minimizer
-			pack::task::PackerTaskOP task = pack::task::TaskFactory::create_packer_task( pose );
-			task->initialize_from_command_line().or_include_current( true );
-			task->restrict_to_repacking();
-
-			kinematics::MoveMapOP mm(new kinematics::MoveMap);
-			mm->set_bb( false );
-
-			// Set up each residue individually
-			for( Size i(1); i <= pose.total_residue(); ++i )
-			{
-				conformation::Residue const& res(pose.residue(i));
-				if( !res.is_protein() )
-					continue;
-
-				// Determine if i is part of disulfides
-				bool is_disulf = false;
-				for(vector1<pair<Size, Size> >::const_iterator
-					disulf(disulfides.begin()), end_disulf(disulfides.end());
-					disulf != end_disulf; ++disulf)
-				{
-					if( i == disulf->first || i == disulf->second ) {
-						is_disulf = true;
-						break;
-					}
-				}
-
-				if( is_disulf ) {
-					// repack & minimize disulfides
-					mm->set_chi(i, true);
-				} else {
-					// Other residues are unchanged
-					task->nonconst_residue_task(i).prevent_repacking();
-				}
-			}
-
-			// Rebuild disulfides
-			core::pose::rebuild_disulfide(pose,disulfides, task, NULL, mm, NULL);
-		}
-	}
-}// core::pose::switch_to_residue_type_set
-
 ///@brief returns a Distance
 core::Real
 pose_max_nbr_radius( Pose const & pose )
diff --git a/src/core/pose/util.hh b/src/core/pose/util.hh
index 12fa816..183b5a0 100644
--- a/src/core/pose/util.hh
+++ b/src/core/pose/util.hh
@@ -367,18 +367,6 @@ remove_upper_terminus_type_from_pose_residue(
 	Size const seqpos
 	);
 
-/// @details the function allows a pose to use a different residue_type_set to
-/// represent all its residues, such as from fullatom residues to centroid
-/// residues, or vice versa. During the switch, corresponding atoms will be
-/// copied. Redundant atoms will be removed (in case from fullatom to centroid)
-/// and missing atoms will be built by ideal geometry (in the case from centroid
-/// to fullatom).
-void
-switch_to_residue_type_set(
-	pose::Pose & pose,
-	std::string const & type_set_name,
-	bool allow_sloppy_match = false
-	);
 
 /// @brief set up a map to look up TORSION_ID by DOF_ID (Map[DOF_ID] = TORISION_ID)
 void
diff --git a/src/core/scoring/constraints/BasicConstraintCreators.cc b/src/core/scoring/constraints/BasicConstraintCreators.cc
index 6faa7a3..02110c8 100644
--- a/src/core/scoring/constraints/BasicConstraintCreators.cc
+++ b/src/core/scoring/constraints/BasicConstraintCreators.cc
@@ -21,7 +21,6 @@
 #include <core/scoring/constraints/AngleConstraint.hh>
 #include <core/scoring/constraints/AtomPairConstraint.hh>
 #include <core/scoring/constraints/BigBinConstraint.hh>
-#include <core/scoring/constraints/BindingSiteConstraint.hh>
 #include <core/scoring/constraints/CoordinateConstraint.hh>
 #include <core/scoring/constraints/DihedralConstraint.hh>
 //#include <core/scoring/constraints/DunbrackConstraint.hh>
@@ -105,18 +104,6 @@ std::string BigBinConstraintCreator::keyname() const
 	return "BigBin";
 }
 
-BindingSiteConstraintCreator::BindingSiteConstraintCreator() {}
-BindingSiteConstraintCreator::~BindingSiteConstraintCreator() {}
-
-ConstraintOP BindingSiteConstraintCreator::create_constraint() const {
-	return new BindingSiteConstraint;
-}
-
-std::string BindingSiteConstraintCreator::keyname() const
-{
-	return "BindingSite";
-}
-
 CoordinateConstraintCreator::CoordinateConstraintCreator() {}
 CoordinateConstraintCreator::~CoordinateConstraintCreator() {}
 
diff --git a/src/core/scoring/constraints/BasicConstraintCreators.hh b/src/core/scoring/constraints/BasicConstraintCreators.hh
index 4b53f93..dff7a36 100644
--- a/src/core/scoring/constraints/BasicConstraintCreators.hh
+++ b/src/core/scoring/constraints/BasicConstraintCreators.hh
@@ -57,17 +57,6 @@ public:
 	virtual std::string keyname() const;
 };
 
-/// @brief Mover creator for the BindingSiteConstraint constraint
-class BindingSiteConstraintCreator : public ConstraintCreator
-{
-public:
-	BindingSiteConstraintCreator();
-	virtual ~BindingSiteConstraintCreator();
-
-	virtual ConstraintOP create_constraint() const;
-	virtual std::string keyname() const;
-};
-
 /// @brief Mover creator for the BigBinConstraint constraint
 class BigBinConstraintCreator : public ConstraintCreator
 {
diff --git a/src/core/scoring/constraints/BindingSiteConstraint.cc b/src/core/scoring/constraints/BindingSiteConstraint.cc
deleted file mode 100644
index 2661713..0000000
--- a/src/core/scoring/constraints/BindingSiteConstraint.cc
+++ /dev/null
@@ -1,392 +0,0 @@
-// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
-// vi: set ts=2 noet:
-//
-// (c) Copyright Rosetta Commons Member Institutions.
-// (c) This file is part of the Rosetta software suite and is made available under license.
-// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
-// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
-// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
-
-/// @file
-/// @brief
-
-// Unit headers
-#include <core/scoring/constraints/BindingSiteConstraint.hh>
-
-// Package headers
-#include <core/scoring/constraints/Constraint.hh>
-#include <core/scoring/constraints/Func.hh>
-#include <core/scoring/constraints/XYZ_Func.hh>
-#include <core/scoring/ScoreType.hh>
-#include <core/scoring/EnergyMap.hh>
-
-// Project headers
-#include <core/conformation/Conformation.hh>
-#include <core/pose/Pose.hh>
-#include <core/id/AtomID.hh>
-// AUTO-REMOVED #include <core/id/NamedAtomID.hh>
-
-#include <core/chemical/ResidueTypeSet.hh>
-// AUTO-REMOVED #include <core/chemical/ChemicalManager.hh>
-#include <numeric/model_quality/rms.hh>
-
-#include <utility/string_util.hh>
-
-// Utility Headers
-#include <basic/Tracer.hh>
-
-//Auto Headers
-#include <core/chemical/ChemicalManager.fwd.hh>
-#include <core/pose/util.hh>
-#include <core/id/SequenceMapping.hh>
-#include <numeric/xyz.functions.hh>
-
-
-static basic::Tracer tr("core.io.constraints");
-
-namespace core {
-namespace scoring {
-namespace constraints {
-
-
-// database of binding sites
-std::map< id::AtomID , numeric::xyzVector< core::Real > > BindingSiteConstraint::rot_db;
-
-///c-tor
-BindingSiteConstraint::BindingSiteConstraint(
-	utility::vector1< AtomID > const & atms,
-	core::pose::Pose const &start_pose,
-	ScoreType scoretype   /// ? TO DO -- give own scoretype
-):
-Constraint( scoretype ),
-atms_(atms) {
-	init ( start_pose );
-}
-
-void BindingSiteConstraint::init( core::pose::Pose const &start_pose ) {
-	// grab binding-site atom positions from starting pose
-	// error-checking is handled in parser -- here we assume #constr >= 2 and all atmids exist
-	numeric::xyzVector< core::Real > com(0,0,0);
-	int natoms = atms_.size();
-
-	tgt_pos_.dimension( 3, natoms );
-	for ( int i = 1; i <= natoms; ++i ) {
-		numeric::xyzVector< core::Real > x_i = start_pose.xyz( atms_[i] );
-		com += x_i;
-		for ( int k = 0; k < 3; ++k )
-			tgt_pos_(k+1,i) = x_i[k];
-	}
-
-	// center at the origin
-	com /= atms_.size();
-	for (int i=1; i<=(int)atms_.size(); ++i)
-		for ( int k = 0; k < 3; ++k )
-			tgt_pos_(k+1,i) -= com[k];
-
-	// also create centroid constraints
-	core::pose::Pose start_pose_copy = start_pose;
-	core::pose::switch_to_residue_type_set( start_pose_copy, core::chemical::CENTROID );
-	com = numeric::xyzVector< core::Real >(0,0,0);
-
-	tgt_pos_centroid_.dimension( 3, natoms );
-	for ( int i = 1; i <= natoms; ++i ) {
-		id::AtomID atm_i;
-		if ( atms_[i].atomno() > 5 )
-			atm_i = id::AtomID( start_pose_copy.residue( atms_[i].rsd()  ).natoms() , atms_[i].rsd() );
-		else
-			atm_i = atms_[i];
-		numeric::xyzVector< core::Real > x_i = start_pose_copy.xyz( atm_i );
-		com += x_i;
-		for ( int k = 0; k < 3; ++k )
-			tgt_pos_centroid_(k+1,i) = x_i[k];
-	}
-
-	// center at the origin
-	com /= atms_.size();
-	for (int i=1; i<=(int)atms_.size(); ++i)
-		for ( int k = 0; k < 3; ++k )
-			tgt_pos_centroid_(k+1,i) -= com[k];
-}
-
-/// ctor from a vector of atom positions (in lieu of a pose)
-BindingSiteConstraint::BindingSiteConstraint(
-	utility::vector1< AtomID > const & atms,
-	ObjexxFCL::FArray2D< core::Real >  tgt_pos,
-	ObjexxFCL::FArray2D< core::Real >  tgt_pos_centroid,
-	ScoreType scoretype   /// ? TO DO -- give own scoretype
-):
-	Constraint( scoretype ),
-	atms_(atms),
-	tgt_pos_(tgt_pos),
-	tgt_pos_centroid_(tgt_pos_centroid)
-{}
-
-///
-void
-BindingSiteConstraint::score( XYZ_Func const&, EnergyMap const &, EnergyMap & emap ) const {
-	// filler
-	//std::cerr << "BindingSiteConstraint::score( XYZ_Func const & xyz, EnergyMap const &, EnergyMap & emap ) " << std::endl;
-
-	// get optimally-aligned RMS
-	core::Real bs_score = 0.0;
-	for (int i=1; i<=(int)atms_.size(); ++i) {
-		core::Real this_dist = rot_db[ atms_[i] ].length();
-		bs_score += this_dist*this_dist;
-		//std::cerr << "   " << bs_score << " <= +" << this_dist << "^2\n";
-	}
-
-	emap[ this->score_type() ] += bs_score;
-}
-
-// do some pre-scoring calculations
-void
-BindingSiteConstraint::setup_for_scoring( XYZ_Func const & xyz, ScoreFunction const & ) const {
-	// filler
-	//std::cerr << "BindingSiteConstraint::setup_for_scoring() " << std::endl;
-
-	// align the >target atoms< to the >template atoms<
-	utility::vector1< numeric::xyzVector< core::Real > > templ_atms;
-	utility::vector1< bool > align_centroid;
-
-	for (int i=1; i<=(int)atms_.size(); ++i) {
-		core::chemical::ResidueType const & rsd_type = xyz.residue( atms_[i].rsd()  ).type();
-		id::AtomID atm_i;
-		bool aln_cent_i = false;
-
-		// is pose centroid?? then we need to remap atmids
-		if ( rsd_type.residue_type_set().name() == core::chemical::CENTROID && atms_[i].atomno() > 5 ) {
-			//std::cerr << "ATOM " << atms_[i].rsd() << " , " << atms_[i].atomno() << "  (" << pose.residue( atms_[i].rsd()  ).natoms() << ")" << std::endl;
-			//std::cerr << "Remapping ATOM " << atms_[i].rsd() << " , " << atms_[i].atomno() << " to CENTROID" << std::endl;
-			atm_i = id::AtomID( xyz.residue( atms_[i].rsd()  ).natoms() , atms_[i].rsd() );
-			aln_cent_i = true;
-		} else {
-			atm_i = atms_[i];
-		}
-
-		templ_atms.push_back( xyz( atm_i ) );
-		align_centroid.push_back( aln_cent_i );
-	}
-	pre_align (templ_atms, align_centroid);
-}
-
-// align the atoms
-//   ... placing a vector  -- from each atom to the the rotated >target< atoms -- in the database
-void
-BindingSiteConstraint::pre_align(
-                utility::vector1< numeric::xyzVector< core::Real > > const & templ_atms,
-                utility::vector1< bool > const & align_centroid
-                                ) const {
-	int natoms = templ_atms.size();
-
-	if ( natoms != (int)atms_.size() ) {
-		utility_exit_with_message( "BindingSiteConstraint::align() bad argument" );
-	}
-
-	// copy coords into Real arrays
-	ObjexxFCL::FArray2D< core::Real > tmpl_pos( 3, natoms );
-	numeric::xyzVector< core::Real > com(0,0,0);
-	for ( int i = 1; i <= natoms; ++i ) {
-		numeric::xyzVector< core::Real > const &x_i = templ_atms[i];
-		com += x_i;
-		for ( int k = 0; k < 3; ++k )
-			tmpl_pos(k+1,i) = x_i[k];
-	}
-
-	// center at the origin
-	com /= natoms;
-	for (int i=1; i<=natoms; ++i)
-		for ( int k = 0; k < 3; ++k )
-			tmpl_pos(k+1,i) -= com[k];
-
-	// get optimal superposition
-	// rotate TARGET to the TEMPLATE
-	ObjexxFCL::FArray1D< numeric::Real > ww( natoms, 1.0 );
-	ObjexxFCL::FArray2D< numeric::Real > uu( 3, 3, 0.0 );
-	numeric::Real ctx;
-	ObjexxFCL::FArray2D< core::Real >  tgt_pos_mixed( 3 , natoms );
-
-	for (int i=1; i<=natoms; ++i) {
-		if (align_centroid[i]) {
-			for ( int k = 1; k <= 3; ++k ) {
-				tgt_pos_mixed(k,i) = tgt_pos_centroid_(k,i);
-			}
-		} else {
-			for ( int k = 1; k <= 3; ++k ) {
-				tgt_pos_mixed(k,i) = tgt_pos_(k,i);
-			}
-		}
-	}
-	ObjexxFCL::FArray2D< core::Real >  tgt_pos_copy( 3 , natoms );
-	for (int i=1; i<=natoms; ++i)
-		for ( int k = 1; k <= 3; ++k )
-			tgt_pos_copy(k,i) = tgt_pos_mixed(k,i);
-
-	numeric::model_quality::findUU( tgt_pos_mixed, tmpl_pos, ww, natoms, uu, ctx );
-
-	numeric::xyzMatrix< core::Real > R;
-	R.xx( uu(1,1) ); R.xy( uu(2,1) ); R.xz( uu(3,1) );
-	R.yx( uu(1,2) ); R.yy( uu(2,2) ); R.yz( uu(3,2) );
-	R.zx( uu(1,3) ); R.zy( uu(2,3) ); R.zz( uu(3,3) );
-
-	// apply rotation
-	// if one atom appears in multiple templates this will overwrite previous atom's position ...
-	//   perhaps this should be checked for in the constraint parser
-	for ( int i = 1; i <= natoms; ++i ) {
-		numeric::xyzVector< core::Real > x_i( tgt_pos_copy(1,i) , tgt_pos_copy(2,i) , tgt_pos_copy(3,i) );
-		numeric::xyzVector< core::Real > rx_i = R*x_i;
-		numeric::xyzVector< core::Real > y_i( tmpl_pos(1,i) , tmpl_pos(2,i) , tmpl_pos(3,i) );
-		//rot_db[ atms_[i] ] = rx_i;
-		rot_db[ atms_[i] ] = (rx_i - y_i);  // store the direction template to target
-
-		///////////////
-		///////////////
-		//std::cerr << "   tgt: ATOM " << i << ": " << tgt_pos_copy(1,i) << " , "
-		//																					<< tgt_pos_copy(2,i) << " , "
-		//																					<< tgt_pos_copy(3,i) << std::endl;
-		//std::cerr << "   tmpl:ATOM " << i << ": " << tmpl_pos(1,i) << " , "
-		//																					<< tmpl_pos(2,i) << " , "
-		//																					<< tmpl_pos(3,i) << std::endl;
-		//std::cerr << "   del: ATOM " << i << ": " << rot_db[ atms_[i] ][0] << " , "
-		//                                          << rot_db[ atms_[i] ][1] << " , "
-		//                                          << rot_db[ atms_[i] ][2] << "\n\n";
-		///////////////
-		///////////////
-	}
-}
-
-// call the setup_for_derivatives for each constraint
-void
-BindingSiteConstraint::setup_for_derivatives( XYZ_Func const & xyz, ScoreFunction const &scfxn ) const {
-	// filler
-	//std::cerr << "BindingSiteConstraint::setup_for_derivatives() " << std::endl;
-	setup_for_scoring( xyz, scfxn );
-}
-
-// atom deriv
-void
-BindingSiteConstraint::fill_f1_f2(
-	AtomID const & atom,
-	XYZ_Func const & xyz,
-	Vector & F1,
-	Vector & F2,
-	EnergyMap const & weights
-) const	{
-	// filler
-	//std::cerr << "BindingSiteConstraint::fill_f1_f2() " << std::endl;
-	if ( std::find( atms_.begin() , atms_.end() , atom ) == atms_.end()) return;
-
-	numeric::xyzVector< core::Real > atom_x = -xyz(atom);
-	numeric::xyzVector< core::Real > const f2( rot_db[ atom ] );
-	numeric::xyzVector< core::Real > atom_y = f2 + atom_x;   // a "fake" atom in the direcion of the gradient
-	numeric::xyzVector< core::Real > const f1( atom_x.cross( atom_y ) );
-
-	//std::cerr << "   f1 = " << f1[0] << " , " << f1[1] << " , " << f1[2] << std::endl;
-	//std::cerr << "   f2 = " << f2[0] << " , " << f2[1] << " , " << f2[2] << std::endl;
-
-	F1 -= f1*weights[ this->score_type() ]*2;
-	F2 -= f2*weights[ this->score_type() ]*2;
-}
-
-std::string
-BindingSiteConstraint::type() const {
-	return "BindingSite";
-}
-
-///
-Size
-BindingSiteConstraint::natoms() const
-{
-	return atms_.size();
-}
-
-ConstraintOP
-BindingSiteConstraint::remap_resid( core::id::SequenceMapping const &seqmap ) const
-{
-	utility::vector1< AtomID > atms_remap;
-
-	for (int i=1; i<=(int) atms_.size(); ++i) {
-		if ( seqmap[atms_[i].rsd()] != 0 ) {
-			atms_remap.push_back( AtomID( atms_[i].atomno(), seqmap[atms_[i].rsd()] ) );
-		}
-	}
-
-	if (atms_remap.size() > 2)
-		return ConstraintOP( new BindingSiteConstraint( atms_remap , tgt_pos_, tgt_pos_centroid_ ) );
-	else
-		return NULL;
-}
-
-///
-core::id::AtomID const &
-BindingSiteConstraint::atom( Size const n ) const
-{
-	if ( n >= 1 && n <= atms_.size() )
-		return atms_[n];
-	else
-		utility_exit_with_message( "BindingSiteConstraint::atom() bad argument" );
-
-	return atms_[1]; // stop the compiler from complaining
-}
-
-void
-BindingSiteConstraint::show( std::ostream& out ) const {
-	out << "BindingSiteConstraint::show() " << std::endl;
-}
-
-void
-BindingSiteConstraint::show_def( std::ostream&  out , pose::Pose const& /* pose */ ) const {
-	out << "BindingSiteConstraint::show_def() " << std::endl;
-}
-
-Size
-BindingSiteConstraint::show_violations( std::ostream& /*out*/, pose::Pose const& /*pose*/, Size /*verbose_level*/, Real /*threshold*/ ) const {
-	/*
-	if (verbose_level > 80) {
-		out << "AtomPairConstraint ("
-				<< pose.residue_type(atom1_.rsd() ).atom_name( atom1_.atomno() ) << ":" << atom1_.atomno() << "," << atom1_.rsd() << "-"
-				<< pose.residue_type(atom2_.rsd() ).atom_name( atom2_.atomno() ) << ":" << atom2_.atomno() << "," << atom2_.rsd() << ") " ;
-	};
-	return func_->show_violations( out, dist( pose ), verbose_level );
-	*/
-	return 0;
-}
-
-///@details one line definition "BindingSite atom1 res1 ... atomN resN"
-void
-BindingSiteConstraint::read_def(
-	std::istream& data,
-	core::pose::Pose const& pose,
-	FuncFactory const& /*func_factory*/
-) {
-	Size res;
-	std::string name;
-
-	std::string line;
-	// = data.getline();
-	getline( data, line );
-	std::vector< std::string > tokens = utility::split( line );
-
-	// to do? atm name -> centroid conversion
-	tr.Debug << "read: ";
-	int npairs = tokens.size() / 2;
-	for (int i=0; i<npairs; ++i) {
-		name = tokens[2*i];
-		res = (core::Size) atoi(tokens[2*i + 1].c_str());
-		tr.Debug << "    " << name << " " << res;
-
-		atms_.push_back( id::AtomID( pose.residue_type( res ).atom_index( name ), res ) );
-		if ( res > pose.total_residue() ) {
-			tr.Debug << "** ignored **";
-			continue;
-		}
-	}
-
-	// get positions from start pose
-	init ( pose );
-}
-
-
-
-}
-}
-}
diff --git a/src/core/scoring/constraints/BindingSiteConstraint.hh b/src/core/scoring/constraints/BindingSiteConstraint.hh
deleted file mode 100644
index f6e50b1..0000000
--- a/src/core/scoring/constraints/BindingSiteConstraint.hh
+++ /dev/null
@@ -1,140 +0,0 @@
-// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
-// vi: set ts=2 noet:
-//
-// (c) Copyright Rosetta Commons Member Institutions.
-// (c) This file is part of the Rosetta software suite and is made available under license.
-// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
-// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
-// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
-
-/// @file
-/// @brief
-
-#ifndef INCLUDED_core_scoring_constraints_BindingSiteConstraint_HH
-#define INCLUDED_core_scoring_constraints_BindingSiteConstraint_HH
-
-// Package headers
-#include <core/scoring/constraints/Constraint.hh>
-#include <core/scoring/constraints/Func.hh>
-#include <core/scoring/constraints/XYZ_Func.fwd.hh>
-#include <core/scoring/ScoreType.hh>
-#include <core/scoring/EnergyMap.fwd.hh>
-#include <core/scoring/constraints/FuncFactory.fwd.hh>
-#include <core/scoring/ScoreFunction.fwd.hh>
-
-// Project headers
-#include <core/pose/Pose.fwd.hh>
-#include <core/id/AtomID.hh>
-
-// ObjexxFCL headers
-#include <ObjexxFCL/FArray2D.hh>
-
-// C++ Headers
-#include <map>
-
-//Auto Headers
-#include <utility/vector1_bool.hh>
-
-
-
-namespace core {
-namespace scoring {
-namespace constraints {
-
-
-
-class BindingSiteConstraint : public Constraint {
-public:
-
-	/// null constructor
-	BindingSiteConstraint( ) :
-			Constraint( atom_pair_constraint )  /// ? TO DO -- give own scoretype
-	{ }
-
-	/// ctor from atom list + input pose
-	BindingSiteConstraint(
-		utility::vector1< AtomID > const & atms,
-		core::pose::Pose const &start_pose,
-		ScoreType scoretype = atom_pair_constraint   /// ? TO DO -- give own scoretype
-	);
-
-	/// ctor from a vector of atom positions (in lieu of a pose)
-	BindingSiteConstraint(
-	  utility::vector1< AtomID > const & atms,
-	  ObjexxFCL::FArray2D< core::Real >  tgt_pos,
-	  ObjexxFCL::FArray2D< core::Real >  tgt_pos_centroid,
-		ScoreType scoretype = atom_pair_constraint   /// ? TO DO -- give own scoretype
-	);
-
-	virtual ConstraintOP clone() const {
-		return new BindingSiteConstraint( atms_, tgt_pos_, tgt_pos_centroid_ );
-	}
-
-	///
-	void
-	score( XYZ_Func const & xyz, EnergyMap const &, EnergyMap & emap ) const;
-
-	// do some pre-scoring calculations
- 	void setup_for_scoring( XYZ_Func const & xyz, ScoreFunction const &scfxn ) const;
-
-	// align the atoms
-	//   ... placing a vector  -- from each atom to the the rotated >target< atoms -- in the database
-	void pre_align( utility::vector1< numeric::xyzVector< core::Real > > const & templ_atms,
-                  utility::vector1< bool > const & ) const;
-
-	// call the setup_for_derivatives for each constraint
- 	void setup_for_derivatives(  XYZ_Func const & xyz, ScoreFunction const &scfxn ) const;
-
-	// atom deriv
-	virtual
-	void
-	fill_f1_f2(
-		AtomID const & atom,
-		XYZ_Func const & xyz,
-		Vector & F1,
-	 	Vector & F2,
-		EnergyMap const & weights
-	) const;
-
-	std::string type() const;
-
-	///
-	Size
-	natoms() const;
-
-	virtual
-	ConstraintOP
-	remap_resid( core::id::SequenceMapping const &seqmap ) const;
-
-	///
-	AtomID const &
-	atom( Size const n ) const;
-
-	void show( std::ostream& out ) const;
-
-	void show_def( std::ostream& out, pose::Pose const & pose ) const;
-	void read_def( std::istream& in, pose::Pose const & pose, FuncFactory const & func_factory );
-
-	Size show_violations( std::ostream & out, pose::Pose const & pose, Size verbose_level, Real threshold = 1.0 ) const;
-
-protected:
-	void init( core::pose::Pose const & start_pose );
-
-private:
-	// data
-	utility::vector1< AtomID > atms_;
-	ObjexxFCL::FArray2D< core::Real >  tgt_pos_;
-	ObjexxFCL::FArray2D< core::Real >  tgt_pos_centroid_;
-
-	// map of pos->tgt in rotated struct
-	static std::map< AtomID , numeric::xyzVector< core::Real > > rot_db;
-
-	// database mapping constraints to RB transformations
-	// static std::map< AtomID , ?? > transformDB;
-};
-
-}
-}
-}
-
-#endif
diff --git a/src/core/scoring/constraints/ConstraintIO.cc b/src/core/scoring/constraints/ConstraintIO.cc
index 83c38ad..cd005d0 100644
--- a/src/core/scoring/constraints/ConstraintIO.cc
+++ b/src/core/scoring/constraints/ConstraintIO.cc
@@ -20,7 +20,7 @@
 #include <core/scoring/constraints/ConstraintSet.hh>
 #include <core/scoring/constraints/Constraints.hh>
 #include <core/scoring/constraints/AtomPairConstraint.hh>
-#include <core/scoring/constraints/BindingSiteConstraint.hh>
+//#include <core/scoring/constraints/BindingSiteConstraint.hh>
 #include <core/scoring/constraints/AngleConstraint.hh>
 #include <core/scoring/constraints/CoordinateConstraint.hh>
 #include <core/scoring/constraints/Func.hh>
@@ -256,6 +256,7 @@ ConstraintIO::read_cst_angles(
 	next_section_name = "";
 }
 
+/*
 void
 ConstraintIO::read_cst_bindingsites(
 	std::istream & data,
@@ -295,6 +296,7 @@ ConstraintIO::read_cst_bindingsites(
 	tr.Debug << "end of file reached" << std::endl;
 	next_section_name = "";
 }
+*/
 
 std::string
 get_section_name ( std::string line ) {
@@ -321,6 +323,48 @@ get_section_name ( std::string line ) {
 	}
 }
 
+void
+ConstraintIO::read_cst_bindingsites(
+   std::istream & data,
+	 std::string & next_section_name,
+	 ConstraintSet & cst_set,
+	 pose::Pose const & pose
+) {
+	tr.Debug << "ConstraintIO::read_cst_angles" << std::endl;
+	std::string line;
+	while( getline( data, line ) ) {
+		Size res;
+		std::string name;
+		std::istringstream line_stream( line );
+		if ( line.find("[" )!=std::string::npos ) { //end of this section
+			tr.Debug << "section end detected in line " << line << std::endl;
+			next_section_name = line;
+			return;
+		}
+
+		// to do? atm name -> centroid conversion
+		/*utility::vector1< id::AtomID > atms;
+			tr.Debug << "read: ";
+			while ( line_stream >> name >> res ) {
+			tr.Debug << "   " << name << " " << res ;
+			atms.push_back( id::AtomID( pose.residue_type( res ).atom_index( name ), res ) );
+			if ( res > pose.total_residue() ) {
+			tr.Debug << "** ignored **";
+			continue;
+			}
+			}
+			tr.Debug << std::endl;
+			cst_set.add_constraint( new BindingSiteConstraint( atms , pose ) );*/
+
+		ConstraintOP bsc = ConstraintFactory::get_instance()->newConstraint( "BindingSite" );
+		bsc->read_def( line_stream, pose, get_func_factory() );
+		cst_set.add_constraint( bsc );
+	}// while getline
+	tr.Debug << "end of file reached" << std::endl;
+	next_section_name = "";
+}
+
+
 ConstraintSetOP
 ConstraintIO::read_constraints(
 	std::string const & fname,
diff --git a/src/core/scoring/disulfides/DisulfideMatchingEnergy.cc b/src/core/scoring/disulfides/DisulfideMatchingEnergy.cc
index 5eb9c3a..dd2ad29 100644
--- a/src/core/scoring/disulfides/DisulfideMatchingEnergy.cc
+++ b/src/core/scoring/disulfides/DisulfideMatchingEnergy.cc
@@ -25,7 +25,6 @@
 #include <core/pose/Pose.hh>
 #include <core/conformation/Residue.hh>
 #include <core/chemical/ResidueTypeSet.hh>
-#include <core/pose/disulfide_util.hh>
 // AUTO-REMOVED #include <core/chemical/ChemicalManager.hh>
 #include <core/scoring/EnergyMap.hh>
 #include <core/scoring/Energies.hh>
diff --git a/src/core/scoring/disulfides/DisulfideMatchingPotential.cc b/src/core/scoring/disulfides/DisulfideMatchingPotential.cc
index 1b0111c..4d9ef5e 100644
--- a/src/core/scoring/disulfides/DisulfideMatchingPotential.cc
+++ b/src/core/scoring/disulfides/DisulfideMatchingPotential.cc
@@ -30,7 +30,6 @@
 // Utility Headers
 #include <utility/io/izstream.hh>
 #include <utility/vector1.hh>
-#include <core/pose/disulfide_util.hh>
 #include <core/conformation/util.hh>
 
 #include <basic/Tracer.hh>
diff --git a/src/devel/anchored_design/InterfaceAnalyzerMover.cc b/src/devel/anchored_design/InterfaceAnalyzerMover.cc
index 4b0bc38..620238f 100644
--- a/src/devel/anchored_design/InterfaceAnalyzerMover.cc
+++ b/src/devel/anchored_design/InterfaceAnalyzerMover.cc
@@ -84,6 +84,7 @@
 
 //Auto Headers
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 using basic::T;
@@ -1207,8 +1208,8 @@ void InterfaceAnalyzerMover::mut_to_gly( core::pose::Pose complex_pose, core::po
 void InterfaceAnalyzerMover::calc_centroid_dG ( core::pose::Pose complex_pose, core::pose::Pose separated_pose ){
 	core::pose::Pose copy_complex( complex_pose );
 	core::pose::Pose copy_separated( separated_pose );
-	core::pose::switch_to_residue_type_set( copy_complex , core::chemical::CENTROID );
-	core::pose::switch_to_residue_type_set( copy_separated , core::chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( copy_complex , core::chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( copy_separated , core::chemical::CENTROID );
 	// use score3 but turn of RG
 	core::scoring::ScoreFunctionOP scorefxn  = core::scoring::ScoreFunctionFactory::create_score_function( "score3" );
 	scorefxn->set_weight( core::scoring::rg, 0.0 );
diff --git a/src/devel/denovo_protein_design/DesignRelaxMover.cc b/src/devel/denovo_protein_design/DesignRelaxMover.cc
index 6e5140f..41a516b 100644
--- a/src/devel/denovo_protein_design/DesignRelaxMover.cc
+++ b/src/devel/denovo_protein_design/DesignRelaxMover.cc
@@ -59,6 +59,7 @@
 #include <core/chemical/ChemicalManager.fwd.hh>
 #include <core/pose/util.hh>
 #include <protocols/relax/ClassicRelax.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 // C++ Headers
@@ -85,7 +86,7 @@ void DesignRelaxMover::apply( core::pose::Pose & pose )
 
 	// we don't know how the pose coming in was created but it needs to be a full atom pose
 	if( !pose.is_fullatom() ){
-		core::pose::switch_to_residue_type_set(pose, core::chemical::FA_STANDARD);
+		protocols::toolbox::switch_to_residue_type_set(pose, core::chemical::FA_STANDARD);
 		TR << "switching pose to be full atom" << std::endl;
 	}
 
diff --git a/src/devel/domain_assembly/domain_assembly.cc b/src/devel/domain_assembly/domain_assembly.cc
index 710c7b6..4cb6e9f 100644
--- a/src/devel/domain_assembly/domain_assembly.cc
+++ b/src/devel/domain_assembly/domain_assembly.cc
@@ -83,6 +83,7 @@
 #include <core/chemical/ChemicalManager.fwd.hh>
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -200,7 +201,7 @@ optimize_linkers_centroid_mode(
 
 
 	core::pose::Pose const saved_input_pose( full_pose ); //used to return sidechains later
-	core::pose::switch_to_residue_type_set( full_pose, core::chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( full_pose, core::chemical::CENTROID );
 	scoring::ScoreFunctionOP scorefxn_centroid( scoring::ScoreFunctionFactory::create_score_function( scoring::CENTROID_WTS ) );
 	MonteCarloOP mc( new MonteCarlo( full_pose, *scorefxn_centroid, 0.8 /*temperature*/ ) );
 
@@ -337,7 +338,7 @@ optimize_linkers_fullatom_mode(
 	pose::Pose & full_pose
 )
 {
-	//core::pose::switch_to_residue_type_set( full_pose, core::chemical::FA_STANDARD );
+	//protocols::toolbox::switch_to_residue_type_set( full_pose, core::chemical::FA_STANDARD );
 	scoring::ScoreFunctionOP scorefxn( scoring::ScoreFunctionFactory::create_score_function(scoring::STANDARD_WTS, scoring::SCORE12_PATCH) );
 
 	// for each residue - identify the nearest movable residue forward and backwards in sequence
diff --git a/src/devel/fold_from_loops/FoldFromLoopsMover.cc b/src/devel/fold_from_loops/FoldFromLoopsMover.cc
index 9034b59..22be74c 100644
--- a/src/devel/fold_from_loops/FoldFromLoopsMover.cc
+++ b/src/devel/fold_from_loops/FoldFromLoopsMover.cc
@@ -94,6 +94,7 @@
 #include <core/chemical/ChemicalManager.fwd.hh>
 #include <core/pose/util.hh>
 #include <protocols/relax/ClassicRelax.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 using namespace core;
@@ -137,7 +138,7 @@ void FoldFromLoopsMover::apply (core::pose::Pose & input_pose )
 
 	std::vector<Size> cut_points;
 
-	core::pose::switch_to_residue_type_set( input_pose, core::chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( input_pose, core::chemical::CENTROID );
 
 
 	core::kinematics::MoveMapOP  movemap = new core::kinematics::MoveMap();
@@ -260,7 +261,7 @@ void FoldFromLoopsMover::apply (core::pose::Pose & input_pose )
 
 			if ( get_last_move_status() == MS_SUCCESS ){
 
-			core::pose::switch_to_residue_type_set( input_pose, chemical::FA_STANDARD );
+			protocols::toolbox::switch_to_residue_type_set( input_pose, chemical::FA_STANDARD );
 
 
 			core::scoring::ScoreFunctionOP scorefxn_fa( ScoreFunctionFactory::create_score_function( STANDARD_WTS, SCORE12_PATCH ) );
diff --git a/src/devel/fold_from_loops/FoldFromLoops_functions.cc b/src/devel/fold_from_loops/FoldFromLoops_functions.cc
index 4a5bb48..66c1fac 100644
--- a/src/devel/fold_from_loops/FoldFromLoops_functions.cc
+++ b/src/devel/fold_from_loops/FoldFromLoops_functions.cc
@@ -62,6 +62,7 @@
 #include <core/chemical/ChemicalManager.fwd.hh>
 #include <core/chemical/VariantType.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 namespace devel {
@@ -588,7 +589,7 @@ void new_pose_generator(
 	core::pose::Pose centroid_target_loops;
 
 
-	core::pose::switch_to_residue_type_set( target_loops , core::chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( target_loops , core::chemical::CENTROID );
 
 	core::chemical::ResidueTypeSet const & rsd_set( target_loops.residue(1).residue_type_set() );
 
diff --git a/src/devel/metal_interface/MetalInterfaceDesignMover.cc b/src/devel/metal_interface/MetalInterfaceDesignMover.cc
index 7219ac5..8f92a75 100644
--- a/src/devel/metal_interface/MetalInterfaceDesignMover.cc
+++ b/src/devel/metal_interface/MetalInterfaceDesignMover.cc
@@ -65,6 +65,7 @@
 //Auto Headers
 #include <core/chemical/ChemicalManager.fwd.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -316,7 +317,7 @@ void MetalInterfaceDesignMover::copy_to_centroid(
 	centroid = pose;
 	centroid.fold_tree(centroid_tree); //"boring" fold tree is centroid safe (no jumps on nonexistent atoms)
 	//centroid.conformation().delete_residue_slow(metal_res);
-	core::pose::switch_to_residue_type_set(centroid, core::chemical::CENTROID);
+	protocols::toolbox::switch_to_residue_type_set(centroid, core::chemical::CENTROID);
 }
 
 
diff --git a/src/devel/ssrbrelax/SSrbrelax.cc b/src/devel/ssrbrelax/SSrbrelax.cc
index 6649161..00f827a 100644
--- a/src/devel/ssrbrelax/SSrbrelax.cc
+++ b/src/devel/ssrbrelax/SSrbrelax.cc
@@ -80,6 +80,7 @@
 
 //Auto Headers
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -142,7 +143,7 @@ namespace ssrbrelax {
 		RbSegments rbsegments;
 
 		//converting to centroid atom types
-		protocols::loops::core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+		protocols::loops::protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 		std::string rb_file;
 		rbsegments.read_segments_from_file();
 		rbsegments.read_param_file();
diff --git a/src/protocols.src.settings b/src/protocols.src.settings
index 1c759f7..868b4ba 100644
--- a/src/protocols.src.settings
+++ b/src/protocols.src.settings
@@ -105,6 +105,7 @@ sources = {
 		"AmbiguousMultiConstraint",
 		"AdditionalConstraintCreators",
 		"SequenceProfileConstraint",
+                "BindingSiteConstraint",
 	],
 
     "protocols/ddg" : [
@@ -1001,6 +1002,8 @@ sources = {
 		"InteratomicVarianceMatrix",
 		"pose_manipulation",
 		"superimpose",
+                "disulfide_util",
+                "SwitchResidueTypeSet",
 	],
 
 	"protocols/toolbox/match_enzdes_util" : [
diff --git a/src/protocols/MultiResolutionProtocol.cc b/src/protocols/MultiResolutionProtocol.cc
index edddcc1..9127362 100644
--- a/src/protocols/MultiResolutionProtocol.cc
+++ b/src/protocols/MultiResolutionProtocol.cc
@@ -2,6 +2,7 @@
 
 //Auto Headers
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 // vi: set ts=2 noet:
 //
@@ -31,7 +32,7 @@ core::pose::Pose ResolutionSwitcher::start_pose() {
   if ( start_centroid_ ) {
     if ( init_fa_ ) {
       pose::Pose pose( init_pose_ );
-      core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+      protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
       return pose;
     } else return init_pose_;
   } else if ( init_fa_ ) {
@@ -77,7 +78,7 @@ bool ResolutionSwitcher::apply( core::pose::Pose &pose ) {
   utility::vector1< bool > needToRepack( pose.total_residue() , false );
   if ( apply_to_centroid_ ) {
     //puts full-atom sidechains on loop regions
-    core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+    protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
     pose.conformation().detect_bonds();//apl fix this !
   }
 
diff --git a/src/protocols/abinitio/AbrelaxApplication.cc b/src/protocols/abinitio/AbrelaxApplication.cc
index d25a7c6..ba4a19c 100644
--- a/src/protocols/abinitio/AbrelaxApplication.cc
+++ b/src/protocols/abinitio/AbrelaxApplication.cc
@@ -241,6 +241,7 @@
 #include <protocols/relax/ClassicRelax.hh>
 #include <protocols/relax/FastRelax.hh>
 #include <protocols/relax/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 #include <ObjexxFCL/format.hh>
 #include <iterator>
 
@@ -523,7 +524,7 @@ void AbrelaxApplication::setup() {
 
 		// allow sloppy matches here, because sometimes the Centroid residue set doesn't have all the residue variants
 		// that the fullatom set has.
-		core::pose::switch_to_residue_type_set( *native_pose_, chemical::CENTROID, true ); //so that in do_rerun the native pose is the same as the other poses
+		protocols::toolbox::switch_to_residue_type_set( *native_pose_, chemical::CENTROID, true ); //so that in do_rerun the native pose is the same as the other poses
 
 		//		for ( Size i = 1; i<=native_pose_->total_residue(); i++ ) {
 		//			std::cout << native_pose_->phi(i) << ' ' << native_pose_->psi(i) << std::endl;
@@ -1163,7 +1164,7 @@ void AbrelaxApplication::do_distributed_rerun() {
 		if ( bRelax_ ) {
 			if ( !pose.is_fullatom() ) {
 				Pose const centroid_pose ( pose );
-				core::pose::switch_to_residue_type_set( pose, chemical::FA_STANDARD );
+				protocols::toolbox::switch_to_residue_type_set( pose, chemical::FA_STANDARD );
 				pose.constraint_set( pose.constraint_set()->remapped_clone( centroid_pose, pose ) );
 			}
 
@@ -2090,7 +2091,7 @@ void AbrelaxApplication::fold( core::pose::Pose &init_pose, ProtocolOP prot_ptr
 				pose::Pose const centroid_pose ( fold_pose );
 				ResolutionSwitcher res_switch( centroid_pose, false, true, true );
 				res_switch.apply( fold_pose );
-				//				core::pose::switch_to_residue_type_set( fold_pose, chemical::FA_STANDARD );
+				//				protocols::toolbox::switch_to_residue_type_set( fold_pose, chemical::FA_STANDARD );
 				//				fold_pose.conformation().detect_bonds();//apl fix this !
 				//				fold_pose.constraint_set( fold_pose.constraint_set()->remapped_clone( centroid_pose, fold_pose ) );
 			}
@@ -2241,7 +2242,7 @@ void AbrelaxApplication::fold( core::pose::Pose &init_pose, ProtocolOP prot_ptr
 					if ( bRelax_ ) {
 						if ( !it->is_fullatom() ) {
 							pose::Pose const centroid_pose ( *it );
-							core::pose::switch_to_residue_type_set( *it, chemical::FA_STANDARD );
+							protocols::toolbox::switch_to_residue_type_set( *it, chemical::FA_STANDARD );
 							it->constraint_set( it->constraint_set()->remapped_clone( centroid_pose, *it ) );
 						}
 						if ( bCanRelax ) {
@@ -2489,7 +2490,7 @@ void AbrelaxApplication::run() {
 // 				relax( pose, fullatom_scorefxn, jobdist.get_current_output_tag() );
 // 			} else { //cannot relax
 // 				//need proper atom set to score with full-atom
-// 				core::pose::switch_to_residue_type_set( pose, chemical::FA_STANDARD );
+// 				protocols::toolbox::switch_to_residue_type_set( pose, chemical::FA_STANDARD );
 // 			}
 // 		} // if ( bRelax_ )
 
diff --git a/src/protocols/abinitio/ResolutionSwitcher.cc b/src/protocols/abinitio/ResolutionSwitcher.cc
index 1bc9b41..5faa855 100644
--- a/src/protocols/abinitio/ResolutionSwitcher.cc
+++ b/src/protocols/abinitio/ResolutionSwitcher.cc
@@ -60,8 +60,9 @@
 
 //Auto Headers
 #include <core/chemical/ChemicalManager.fwd.hh>
-#include <core/pose/util.hh>
 #include <core/id/SequenceMapping.hh>
+#include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 #include <utility/options/keys/BooleanOptionKey.hh>
 
 
@@ -130,7 +131,7 @@ core::pose::Pose ResolutionSwitcher::start_pose() const {
   if ( start_centroid_ ) {
     if ( init_fa_ ) {
       pose::Pose pose( init_pose_ );
-      core::pose::switch_to_residue_type_set( pose, chemical::CENTROID );
+      protocols::toolbox::switch_to_residue_type_set( pose, chemical::CENTROID );
       return pose;
     } else return init_pose_;
   } else if ( init_fa_ ) {
@@ -151,7 +152,7 @@ void ResolutionSwitcher::apply( pose::Pose &pose ) {
   if ( apply_to_centroid_ ) {
     //puts full-atom sidechains on loop regions
 		tr.Debug <<" change to full-atom pose " << std::endl;
-    core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+    protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
     pose.conformation().detect_bonds();//apl fix this !
   }
 
diff --git a/src/protocols/abinitio/Templates.cc b/src/protocols/abinitio/Templates.cc
index 35791b7..2950dc4 100644
--- a/src/protocols/abinitio/Templates.cc
+++ b/src/protocols/abinitio/Templates.cc
@@ -72,6 +72,7 @@
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
 #include <core/scoring/constraints/NamedAtomPairConstraint.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 #include <utility/io/mpistream.hh>
 
 
@@ -141,7 +142,7 @@ void StructureStore::add( std::string const& file_name ) {
 		core::import_pose::pose_from_pdb( *pose, file_name );
 
 		// switch to centroid --- such that constraints get correct atom numbers assigned
-		core::pose::switch_to_residue_type_set( *pose, chemical::CENTROID );
+		protocols::toolbox::switch_to_residue_type_set( *pose, chemical::CENTROID );
 
 		// set ss structure -- good for fragpicking
 		pose::set_ss_from_phipsi( *pose );
diff --git a/src/protocols/comparative_modeling/ThreadingMover.cc b/src/protocols/comparative_modeling/ThreadingMover.cc
index 586d362..3926a43 100644
--- a/src/protocols/comparative_modeling/ThreadingMover.cc
+++ b/src/protocols/comparative_modeling/ThreadingMover.cc
@@ -69,6 +69,7 @@
 
 //Auto Headers
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 namespace protocols {
@@ -380,8 +381,8 @@ void ThreadingMover::apply(
 				query_pose.residue_type(1).residue_type_set().name()
 			);
 
-			using core::pose::switch_to_residue_type_set;
-			core::pose::switch_to_residue_type_set( query_pose, core::chemical::CENTROID );
+			using protocols::toolbox::switch_to_residue_type_set;
+			protocols::toolbox::switch_to_residue_type_set( query_pose, core::chemical::CENTROID );
 
 			loops::LoopMoverOP loop_mover = protocols::loops::get_loop_mover(
 				option[ cm::loop_mover ](), query_loops
@@ -393,7 +394,7 @@ void ThreadingMover::apply(
 
 			// switch back to original ResidueTypeSet after loop modeling
 			if ( orig_rsd_set_name != core::chemical::CENTROID ) {
-				core::pose::switch_to_residue_type_set(
+				protocols::toolbox::switch_to_residue_type_set(
 					query_pose,
 					orig_rsd_set_name
 				);
diff --git a/src/protocols/comparative_modeling/util.cc b/src/protocols/comparative_modeling/util.cc
index 8b9ebc6..2265f00 100644
--- a/src/protocols/comparative_modeling/util.cc
+++ b/src/protocols/comparative_modeling/util.cc
@@ -67,6 +67,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 namespace protocols {
@@ -320,7 +321,7 @@ void rebuild_loops_until_closed(
 	std::string const orig_rsd_set_name(
 		query_pose.residue_type(1).residue_type_set().name()
 	);
-	core::pose::switch_to_residue_type_set( query_pose, core::chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( query_pose, core::chemical::CENTROID );
 
 	bool closed( false );
 	for ( core::Size iter = 1; !closed && iter <= max_rebuild; iter++ ) {
@@ -342,7 +343,7 @@ void rebuild_loops_until_closed(
 
 	tr.flush();
 
-	core::pose::switch_to_residue_type_set( query_pose, orig_rsd_set_name );
+	protocols::toolbox::switch_to_residue_type_set( query_pose, orig_rsd_set_name );
 } // rebuild_loops_until_closed
 
 void steal_ligands(
diff --git a/src/protocols/constraints_additional/AdditionalConstraintCreators.cc b/src/protocols/constraints_additional/AdditionalConstraintCreators.cc
index 8e9014d..bbbe322 100644
--- a/src/protocols/constraints_additional/AdditionalConstraintCreators.cc
+++ b/src/protocols/constraints_additional/AdditionalConstraintCreators.cc
@@ -18,10 +18,25 @@
 /// Project Headers
 #include <protocols/constraints_additional/SequenceProfileConstraint.hh>
 #include <core/scoring/constraints/NamedAtomPairConstraint.hh>
+#include <protocols/constraints_additional/BindingSiteConstraint.hh>
 
 namespace protocols {
 namespace constraints_additional {
 
+
+BindingSiteConstraintCreator::BindingSiteConstraintCreator() {}
+BindingSiteConstraintCreator::~BindingSiteConstraintCreator() {}
+
+core::scoring::constraints::ConstraintOP
+BindingSiteConstraintCreator::create_constraint() const {
+	return new BindingSiteConstraint;
+}
+
+std::string BindingSiteConstraintCreator::keyname() const
+{
+	return "BindingSite";
+}
+
 SequenceProfileConstraintCreator::SequenceProfileConstraintCreator() {}
 SequenceProfileConstraintCreator::~SequenceProfileConstraintCreator() {}
 
diff --git a/src/protocols/constraints_additional/AdditionalConstraintCreators.hh b/src/protocols/constraints_additional/AdditionalConstraintCreators.hh
index fddbaae..968ac4d 100644
--- a/src/protocols/constraints_additional/AdditionalConstraintCreators.hh
+++ b/src/protocols/constraints_additional/AdditionalConstraintCreators.hh
@@ -20,6 +20,18 @@
 namespace protocols {
 namespace constraints_additional {
 
+
+/// @brief Mover creator for the BindingSiteConstraint constraint
+class BindingSiteConstraintCreator : public core::scoring::constraints::ConstraintCreator
+{
+public:
+	BindingSiteConstraintCreator();
+	virtual ~BindingSiteConstraintCreator();
+
+	virtual core::scoring::constraints::ConstraintOP create_constraint() const;
+	virtual std::string keyname() const;
+};
+
 /// @brief Mover creator for the SequenceProfileConstraint constraint
 class SequenceProfileConstraintCreator : public core::scoring::constraints::ConstraintCreator
 {
diff --git a/src/protocols/constraints_additional/BindingSiteConstraint.cc b/src/protocols/constraints_additional/BindingSiteConstraint.cc
new file mode 100644
index 0000000..4a49e73
--- /dev/null
+++ b/src/protocols/constraints_additional/BindingSiteConstraint.cc
@@ -0,0 +1,421 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file
+/// @brief
+
+// Unit headers
+#include <protocols/constraints_additional/BindingSiteConstraint.hh>
+
+// Package headers
+#include <core/scoring/constraints/Constraint.hh>
+#include <core/scoring/constraints/Func.hh>
+#include <core/scoring/constraints/XYZ_Func.hh>
+#include <core/scoring/ScoreType.hh>
+#include <core/scoring/EnergyMap.hh>
+
+// Project headers
+#include <core/conformation/Conformation.hh>
+#include <core/pose/Pose.hh>
+#include <core/id/AtomID.hh>
+// AUTO-REMOVED #include <core/id/NamedAtomID.hh>
+
+#include <core/chemical/ResidueType.hh>
+#include <core/chemical/ResidueTypeSet.hh>
+// AUTO-REMOVED #include <core/chemical/ChemicalManager.hh>
+#include <numeric/model_quality/rms.hh>
+
+#include <utility/string_util.hh>
+
+// Utility Headers
+#include <basic/Tracer.hh>
+
+//Auto Headers
+#include <core/chemical/ChemicalManager.fwd.hh>
+#include <core/id/SequenceMapping.hh>
+#include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
+#include <numeric/xyz.functions.hh>
+
+
+static basic::Tracer tr("core.io.constraints");
+
+namespace protocols {
+namespace constraints_additional {
+
+// database of binding sites
+std::map< core::id::AtomID , numeric::xyzVector< core::Real > > protocols::constraints_additional::BindingSiteConstraint::rot_db;
+
+///c-tor
+BindingSiteConstraint::BindingSiteConstraint(
+	utility::vector1< AtomID > const & atms,
+	core::pose::Pose const &start_pose,
+	core::scoring::ScoreType scoretype   /// ? TO DO -- give own scoretype
+):
+Constraint( scoretype ),
+atms_(atms) {
+	init ( start_pose );
+}
+
+void BindingSiteConstraint::init( core::pose::Pose const &start_pose ) {
+	// grab binding-site atom positions from starting pose
+	// error-checking is handled in parser -- here we assume #constr >= 2 and all atmids exist
+	numeric::xyzVector< core::Real > com(0,0,0);
+	int natoms = atms_.size();
+
+	tgt_pos_.dimension( 3, natoms );
+	for ( int i = 1; i <= natoms; ++i ) {
+		numeric::xyzVector< core::Real > x_i = start_pose.xyz( atms_[i] );
+		com += x_i;
+		for ( int k = 0; k < 3; ++k )
+			tgt_pos_(k+1,i) = x_i[k];
+	}
+
+	// center at the origin
+	com /= atms_.size();
+	for (int i=1; i<=(int)atms_.size(); ++i)
+		for ( int k = 0; k < 3; ++k )
+			tgt_pos_(k+1,i) -= com[k];
+
+	// also create centroid constraints
+	core::pose::Pose start_pose_copy = start_pose;
+	protocols::toolbox::switch_to_residue_type_set( start_pose_copy, core::chemical::CENTROID );
+	com = numeric::xyzVector< core::Real >(0,0,0);
+
+	tgt_pos_centroid_.dimension( 3, natoms );
+	for ( int i = 1; i <= natoms; ++i ) {
+		core::id::AtomID atm_i;
+		if ( atms_[i].atomno() > 5 )
+			atm_i = core::id::AtomID( start_pose_copy.residue( atms_[i].rsd()  ).natoms() , atms_[i].rsd() );
+		else
+			atm_i = atms_[i];
+		numeric::xyzVector< core::Real > x_i = start_pose_copy.xyz( atm_i );
+		com += x_i;
+		for ( int k = 0; k < 3; ++k )
+			tgt_pos_centroid_(k+1,i) = x_i[k];
+	}
+
+	// center at the origin
+	com /= atms_.size();
+	for (int i=1; i<=(int)atms_.size(); ++i)
+		for ( int k = 0; k < 3; ++k )
+			tgt_pos_centroid_(k+1,i) -= com[k];
+}
+
+/// ctor from a vector of atom positions (in lieu of a pose)
+BindingSiteConstraint::BindingSiteConstraint(
+	utility::vector1< AtomID > const & atms,
+	ObjexxFCL::FArray2D< core::Real >  tgt_pos,
+	ObjexxFCL::FArray2D< core::Real >  tgt_pos_centroid,
+	core::scoring::ScoreType scoretype   /// ? TO DO -- give own scoretype
+):
+	Constraint( scoretype ),
+	atms_(atms),
+	tgt_pos_(tgt_pos),
+	tgt_pos_centroid_(tgt_pos_centroid)
+{}
+
+///
+void
+BindingSiteConstraint::score( core::scoring::constraints::XYZ_Func const&, core::scoring::EnergyMap const &, core::scoring::EnergyMap & emap ) const {
+	// filler
+	//std::cerr << "BindingSiteConstraint::score( core::scoring::constraints::XYZ_Func const & xyz, core::scoring::EnergyMap const &, core::scoring::EnergyMap & emap ) " << std::endl;
+
+	// get optimally-aligned RMS
+	core::Real bs_score = 0.0;
+	for (int i=1; i<=(int)atms_.size(); ++i) {
+		core::Real this_dist = rot_db[ atms_[i] ].length();
+		bs_score += this_dist*this_dist;
+		//std::cerr << "   " << bs_score << " <= +" << this_dist << "^2\n";
+	}
+
+	emap[ this->score_type() ] += bs_score;
+}
+
+// do some pre-scoring calculations
+void
+BindingSiteConstraint::setup_for_scoring( core::scoring::constraints::XYZ_Func const & xyz, core::scoring::ScoreFunction const & ) const {
+	// filler
+	//std::cerr << "BindingSiteConstraint::setup_for_scoring() " << std::endl;
+
+	// align the >target atoms< to the >template atoms<
+	utility::vector1< numeric::xyzVector< core::Real > > templ_atms;
+	utility::vector1< bool > align_centroid;
+
+	for (int i=1; i<=(int)atms_.size(); ++i) {
+		core::chemical::ResidueType const & rsd_type = xyz.residue( atms_[i].rsd()  ).type();
+		core::id::AtomID atm_i;
+		bool aln_cent_i = false;
+
+		// is pose centroid?? then we need to remap atmids
+		if ( rsd_type.residue_type_set().name() == core::chemical::CENTROID && atms_[i].atomno() > 5 ) {
+			//std::cerr << "ATOM " << atms_[i].rsd() << " , " << atms_[i].atomno() << "  (" << pose.residue( atms_[i].rsd()  ).natoms() << ")" << std::endl;
+			//std::cerr << "Remapping ATOM " << atms_[i].rsd() << " , " << atms_[i].atomno() << " to CENTROID" << std::endl;
+			atm_i = core::id::AtomID( xyz.residue( atms_[i].rsd()  ).natoms() , atms_[i].rsd() );
+			aln_cent_i = true;
+		} else {
+			atm_i = atms_[i];
+		}
+
+		templ_atms.push_back( xyz( atm_i ) );
+		align_centroid.push_back( aln_cent_i );
+	}
+	pre_align (templ_atms, align_centroid);
+}
+
+// align the atoms
+//   ... placing a vector  -- from each atom to the the rotated >target< atoms -- in the database
+void
+BindingSiteConstraint::pre_align(
+                utility::vector1< numeric::xyzVector< core::Real > > const & templ_atms,
+                utility::vector1< bool > const & align_centroid
+                                ) const {
+	int natoms = templ_atms.size();
+
+	if ( natoms != (int)atms_.size() ) {
+		utility_exit_with_message( "BindingSiteConstraint::align() bad argument" );
+	}
+
+	// copy coords into Real arrays
+	ObjexxFCL::FArray2D< core::Real > tmpl_pos( 3, natoms );
+	numeric::xyzVector< core::Real > com(0,0,0);
+	for ( int i = 1; i <= natoms; ++i ) {
+		numeric::xyzVector< core::Real > const &x_i = templ_atms[i];
+		com += x_i;
+		for ( int k = 0; k < 3; ++k )
+			tmpl_pos(k+1,i) = x_i[k];
+	}
+
+	// center at the origin
+	com /= natoms;
+	for (int i=1; i<=natoms; ++i)
+		for ( int k = 0; k < 3; ++k )
+			tmpl_pos(k+1,i) -= com[k];
+
+	// get optimal superposition
+	// rotate TARGET to the TEMPLATE
+	ObjexxFCL::FArray1D< numeric::Real > ww( natoms, 1.0 );
+	ObjexxFCL::FArray2D< numeric::Real > uu( 3, 3, 0.0 );
+	numeric::Real ctx;
+	ObjexxFCL::FArray2D< core::Real >  tgt_pos_mixed( 3 , natoms );
+
+	for (int i=1; i<=natoms; ++i) {
+		if (align_centroid[i]) {
+			for ( int k = 1; k <= 3; ++k ) {
+				tgt_pos_mixed(k,i) = tgt_pos_centroid_(k,i);
+			}
+		} else {
+			for ( int k = 1; k <= 3; ++k ) {
+				tgt_pos_mixed(k,i) = tgt_pos_(k,i);
+			}
+		}
+	}
+	ObjexxFCL::FArray2D< core::Real >  tgt_pos_copy( 3 , natoms );
+	for (int i=1; i<=natoms; ++i)
+		for ( int k = 1; k <= 3; ++k )
+			tgt_pos_copy(k,i) = tgt_pos_mixed(k,i);
+
+	numeric::model_quality::findUU( tgt_pos_mixed, tmpl_pos, ww, natoms, uu, ctx );
+
+	numeric::xyzMatrix< core::Real > R;
+	R.xx( uu(1,1) ); R.xy( uu(2,1) ); R.xz( uu(3,1) );
+	R.yx( uu(1,2) ); R.yy( uu(2,2) ); R.yz( uu(3,2) );
+	R.zx( uu(1,3) ); R.zy( uu(2,3) ); R.zz( uu(3,3) );
+
+	// apply rotation
+	// if one atom appears in multiple templates this will overwrite previous atom's position ...
+	//   perhaps this should be checked for in the constraint parser
+	for ( int i = 1; i <= natoms; ++i ) {
+		numeric::xyzVector< core::Real > x_i( tgt_pos_copy(1,i) , tgt_pos_copy(2,i) , tgt_pos_copy(3,i) );
+		numeric::xyzVector< core::Real > rx_i = R*x_i;
+		numeric::xyzVector< core::Real > y_i( tmpl_pos(1,i) , tmpl_pos(2,i) , tmpl_pos(3,i) );
+		//rot_db[ atms_[i] ] = rx_i;
+		rot_db[ atms_[i] ] = (rx_i - y_i);  // store the direction template to target
+
+		///////////////
+		///////////////
+		//std::cerr << "   tgt: ATOM " << i << ": " << tgt_pos_copy(1,i) << " , "
+		//																					<< tgt_pos_copy(2,i) << " , "
+		//																					<< tgt_pos_copy(3,i) << std::endl;
+		//std::cerr << "   tmpl:ATOM " << i << ": " << tmpl_pos(1,i) << " , "
+		//																					<< tmpl_pos(2,i) << " , "
+		//																					<< tmpl_pos(3,i) << std::endl;
+		//std::cerr << "   del: ATOM " << i << ": " << rot_db[ atms_[i] ][0] << " , "
+		//                                          << rot_db[ atms_[i] ][1] << " , "
+		//                                          << rot_db[ atms_[i] ][2] << "\n\n";
+		///////////////
+		///////////////
+	}
+}
+
+// call the setup_for_derivatives for each constraint
+void
+BindingSiteConstraint::setup_for_derivatives( core::scoring::constraints::XYZ_Func const & xyz, core::scoring::ScoreFunction const &scfxn ) const {
+	// filler
+	//std::cerr << "BindingSiteConstraint::setup_for_derivatives() " << std::endl;
+	setup_for_scoring( xyz, scfxn );
+}
+
+// atom deriv
+void
+BindingSiteConstraint::fill_f1_f2(
+	AtomID const & atom,
+	core::scoring::constraints::XYZ_Func const & xyz,
+	core::Vector & F1,
+	core::Vector & F2,
+	core::scoring::EnergyMap const & weights
+) const	{
+	// filler
+	//std::cerr << "BindingSiteConstraint::fill_f1_f2() " << std::endl;
+	if ( std::find( atms_.begin() , atms_.end() , atom ) == atms_.end()) return;
+
+	numeric::xyzVector< core::Real > atom_x = -xyz(atom);
+	numeric::xyzVector< core::Real > const f2( rot_db[ atom ] );
+	numeric::xyzVector< core::Real > atom_y = f2 + atom_x;   // a "fake" atom in the direcion of the gradient
+	numeric::xyzVector< core::Real > const f1( atom_x.cross( atom_y ) );
+
+	//std::cerr << "   f1 = " << f1[0] << " , " << f1[1] << " , " << f1[2] << std::endl;
+	//std::cerr << "   f2 = " << f2[0] << " , " << f2[1] << " , " << f2[2] << std::endl;
+
+	F1 -= f1*weights[ this->score_type() ]*2;
+	F2 -= f2*weights[ this->score_type() ]*2;
+}
+
+std::string
+BindingSiteConstraint::type() const {
+	return "BindingSite";
+}
+
+///
+core::Size
+BindingSiteConstraint::natoms() const
+{
+	return atms_.size();
+}
+
+core::scoring::constraints::ConstraintOP
+BindingSiteConstraint::remap_resid( core::id::SequenceMapping const &seqmap ) const
+{
+	utility::vector1< AtomID > atms_remap;
+
+	for (int i=1; i<=(int) atms_.size(); ++i) {
+		if ( seqmap[atms_[i].rsd()] != 0 ) {
+			atms_remap.push_back( AtomID( atms_[i].atomno(), seqmap[atms_[i].rsd()] ) );
+		}
+	}
+
+	if (atms_remap.size() > 2)
+		return core::scoring::constraints::ConstraintOP( new BindingSiteConstraint( atms_remap , tgt_pos_, tgt_pos_centroid_ ) );
+	else
+		return NULL;
+}
+
+///
+core::id::AtomID const &
+BindingSiteConstraint::atom( core::Size const n ) const
+{
+	if ( n >= 1 && n <= atms_.size() )
+		return atms_[n];
+	else
+		utility_exit_with_message( "BindingSiteConstraint::atom() bad argument" );
+
+	return atms_[1]; // stop the compiler from complaining
+}
+
+void
+BindingSiteConstraint::show( std::ostream& out ) const {
+	out << "BindingSiteConstraint::show() " << std::endl;
+}
+
+void
+BindingSiteConstraint::show_def( std::ostream&  out , core::pose::Pose const& /* pose */ ) const {
+	out << "BindingSiteConstraint::show_def() " << std::endl;
+}
+
+core::Size
+BindingSiteConstraint::show_violations( std::ostream& /*out*/, core::pose::Pose const& /*pose*/, core::Size /*verbose_level*/, core::Real /*threshold*/ ) const {
+	/*
+	if (verbose_level > 80) {
+		out << "AtomPairConstraint ("
+				<< core::pose.residue_type(atom1_.rsd() ).atom_name( atom1_.atomno() ) << ":" << atom1_.atomno() << "," << atom1_.rsd() << "-"
+				<< core::pose.residue_type(atom2_.rsd() ).atom_name( atom2_.atomno() ) << ":" << atom2_.atomno() << "," << atom2_.rsd() << ") " ;
+	};
+	return func_->show_violations( out, dist( pose ), verbose_level );
+	*/
+	return 0;
+}
+
+/*
+///@details one line definition "BindingSite atom1 res1 ... atomN resN"
+void
+BindingSiteConstraint::read_def(
+	std::istream& data,
+	core::pose::Pose const& pose,
+	core::scoring::constraints::FuncFactory const& func_factory
+) {
+	core::Size res;
+	std::string name;
+
+	std::string line;
+	// = data.getline();
+	getline( data, line );
+	std::vector< std::string > tokens = utility::split( line );
+
+	// to do? atm name -> centroid conversion
+	tr.Debug << "read: ";
+	int npairs = tokens.size() / 2;
+	for (int i=0; i<npairs; ++i) {
+		name = tokens[2*i];
+		res = (core::Size) atoi(tokens[2*i + 1].c_str());
+		tr.Debug << "    " << name << " " << res;
+
+		atms_.push_back( core::id::AtomID( pose.residue_type( res ).atom_index( name ), res ) );
+		if ( res > pose.total_residue() ) {
+			tr.Debug << "** ignored **";
+			continue;
+		}
+	}
+
+	// get positions from start pose
+	init ( pose );
+}
+*/
+
+/// @brief Format should look like:
+/// Dunbrack seqpos_ rot_vec_pos_ rot_bin_ bonus_
+void
+BindingSiteConstraint::read_def(
+	std::istream & line_stream,
+	core::pose::Pose const & pose,
+	core::scoring::constraints::FuncFactory const & /* func_factory */
+) {
+
+	core::Size res; // ?
+	std::string name; // ?
+
+	// to do? atm name -> centroid conversion
+	utility::vector1< core::id::AtomID > atms;
+	tr.Debug << "read: ";
+	while ( line_stream >> name >> res ) {
+		tr.Debug << "   " << name << " " << res ;
+		atms.push_back( core::id::AtomID( pose.residue_type( res ).atom_index( name ), res ) );
+		if ( res > pose.total_residue() ) {
+			tr.Debug << "** ignored **";
+			continue;
+		}
+	}
+	tr.Debug << std::endl;
+	atms_ = atms;
+	init( pose );
+}
+
+
+
+}
+}
diff --git a/src/protocols/constraints_additional/BindingSiteConstraint.hh b/src/protocols/constraints_additional/BindingSiteConstraint.hh
new file mode 100644
index 0000000..85767f4
--- /dev/null
+++ b/src/protocols/constraints_additional/BindingSiteConstraint.hh
@@ -0,0 +1,136 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file
+/// @brief
+
+#ifndef INCLUDED_protocols_constraints_additional_BindingSiteConstraint_HH
+#define INCLUDED_protocols_constraints_additional_BindingSiteConstraint_HH
+
+// Package headers
+#include <core/scoring/constraints/Constraint.hh>
+#include <core/scoring/constraints/Func.hh>
+#include <core/scoring/constraints/XYZ_Func.fwd.hh>
+#include <core/scoring/ScoreType.hh>
+#include <core/scoring/EnergyMap.fwd.hh>
+#include <core/scoring/constraints/FuncFactory.fwd.hh>
+#include <core/scoring/ScoreFunction.fwd.hh>
+
+// Project headers
+#include <core/pose/Pose.fwd.hh>
+#include <core/id/AtomID.hh>
+
+// ObjexxFCL headers
+#include <ObjexxFCL/FArray2D.hh>
+
+// C++ Headers
+#include <map>
+
+//Auto Headers
+#include <utility/vector1_bool.hh>
+
+
+
+namespace protocols {
+namespace constraints_additional {
+
+class BindingSiteConstraint : public core::scoring::constraints::Constraint {
+public:
+
+	/// null constructor
+	BindingSiteConstraint( ) :
+		core::scoring::constraints::Constraint( core::scoring::atom_pair_constraint )  /// ? TO DO -- give own scoretype
+	{ }
+
+	/// ctor from atom list + input pose
+	BindingSiteConstraint(
+		utility::vector1< AtomID > const & atms,
+		core::pose::Pose const &start_pose,
+		core::scoring::ScoreType scoretype = core::scoring::atom_pair_constraint   /// ? TO DO -- give own scoretype
+	);
+
+	/// ctor from a vector of atom positions (in lieu of a pose)
+	BindingSiteConstraint(
+	  utility::vector1< AtomID > const & atms,
+	  ObjexxFCL::FArray2D< core::Real >  tgt_pos,
+	  ObjexxFCL::FArray2D< core::Real >  tgt_pos_centroid,
+		core::scoring::ScoreType scoretype = core::scoring::atom_pair_constraint   /// ? TO DO -- give own scoretype
+	);
+
+	virtual core::scoring::constraints::ConstraintOP clone() const {
+		return new BindingSiteConstraint( atms_, tgt_pos_, tgt_pos_centroid_ );
+	}
+
+	///
+	void
+	score( core::scoring::constraints::XYZ_Func const & xyz, core::scoring::EnergyMap const &, core::scoring::EnergyMap & emap ) const;
+
+	// do some pre-scoring calculations
+ 	void setup_for_scoring( core::scoring::constraints::XYZ_Func const & xyz, core::scoring::ScoreFunction const &scfxn ) const;
+
+	// align the atoms
+	//   ... placing a vector  -- from each atom to the the rotated >target< atoms -- in the database
+	void pre_align( utility::vector1< numeric::xyzVector< core::Real > > const & templ_atms,
+                  utility::vector1< bool > const & ) const;
+
+	// call the setup_for_derivatives for each constraint
+ 	void setup_for_derivatives(  core::scoring::constraints::XYZ_Func const & xyz, core::scoring::ScoreFunction const &scfxn ) const;
+
+	// atom deriv
+	virtual
+	void
+	fill_f1_f2(
+		AtomID const & atom,
+		core::scoring::constraints::XYZ_Func const & xyz,
+		core::Vector & F1,
+	 	core::Vector & F2,
+		core::scoring::EnergyMap const & weights
+	) const;
+
+	std::string type() const;
+
+	///
+	Size
+	natoms() const;
+
+	virtual
+	core::scoring::constraints::ConstraintOP
+	remap_resid( core::id::SequenceMapping const &seqmap ) const;
+
+	///
+	AtomID const &
+	atom( Size const n ) const;
+
+	void show( std::ostream& out ) const;
+
+	void show_def( std::ostream& out, core::pose::Pose const & pose ) const;
+	void read_def( std::istream& in, core::pose::Pose const & pose, core::scoring::constraints::FuncFactory const & func_factory );
+
+	Size show_violations( std::ostream & out, core::pose::Pose const & pose, core::Size verbose_level, core::Real threshold = 1.0 ) const;
+
+protected:
+	void init( core::pose::Pose const & start_pose );
+
+private:
+	// data
+	utility::vector1< AtomID > atms_;
+	ObjexxFCL::FArray2D< core::Real >  tgt_pos_;
+	ObjexxFCL::FArray2D< core::Real >  tgt_pos_centroid_;
+
+	// map of pos->tgt in rotated struct
+	static std::map< AtomID , numeric::xyzVector< core::Real > > rot_db;
+
+	// database mapping constraints to RB transformations
+	// static std::map< AtomID , ?? > transformDB;
+};
+
+}
+}
+
+#endif
diff --git a/src/protocols/domain_assembly/AssembleLinkerMover.cc b/src/protocols/domain_assembly/AssembleLinkerMover.cc
index 4d464d1..0ca9e7e 100644
--- a/src/protocols/domain_assembly/AssembleLinkerMover.cc
+++ b/src/protocols/domain_assembly/AssembleLinkerMover.cc
@@ -67,8 +67,9 @@
 #include <basic/options/keys/constraints.OptionKeys.gen.hh>
 
 //Auto Headers
-#include <basic/options/option.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
+#include <basic/options/option.hh>
 
 
 namespace protocols {
@@ -103,7 +104,7 @@ void AssembleLinkerMover::apply( core::pose::Pose & pose ) {
 		Size const loop_start( breakpoint - min_loop_size_ );
 		Size const loop_stop ( breakpoint + min_loop_size_ );
 
-		core::pose::switch_to_residue_type_set(
+		protocols::toolbox::switch_to_residue_type_set(
 			pose, core::chemical::CENTROID
 		);
 
@@ -128,7 +129,7 @@ void AssembleLinkerMover::apply( core::pose::Pose & pose ) {
 			}
 		}
 
-		core::pose::switch_to_residue_type_set(
+		protocols::toolbox::switch_to_residue_type_set(
 			pose, core::chemical::FA_STANDARD
 		);
 } // apply
diff --git a/src/protocols/fldsgn/BluePrintBDR.cc b/src/protocols/fldsgn/BluePrintBDR.cc
index f4b5905..4c57ddb 100644
--- a/src/protocols/fldsgn/BluePrintBDR.cc
+++ b/src/protocols/fldsgn/BluePrintBDR.cc
@@ -72,6 +72,7 @@
 #include <core/pose/util.hh>
 #include <protocols/jobdist/Jobs.hh>
 #include <protocols/jumping/StrandPairing.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 #include <protocols/toolbox/pose_metric_calculators/NeighborhoodByDistanceCalculator.fwd.hh>
 
 
@@ -423,7 +424,7 @@ bool BluePrintBDR::centroid_build(
 	using core::scoring::ScoreFunctionFactory;
 	using protocols::moves::MS_SUCCESS;
 
-	using core::pose::switch_to_residue_type_set;
+	using protocols::toolbox::switch_to_residue_type_set;
 	using protocols::forge::methods::restore_residues;
 	using protocols::toolbox::pose_manipulation::construct_poly_ala_pose;
 
@@ -443,7 +444,7 @@ bool BluePrintBDR::centroid_build(
 	}
 
 	if ( !mod_ap_is_full_atom ) {
-		core::pose::switch_to_residue_type_set( modified_archive_pose, core::chemical::FA_STANDARD );
+		protocols::toolbox::switch_to_residue_type_set( modified_archive_pose, core::chemical::FA_STANDARD );
 	}
 
 	// flip to poly-ala-gly-pro-disulf pose
diff --git a/src/protocols/flxbb/FlxbbDesign.cc b/src/protocols/flxbb/FlxbbDesign.cc
index 02581f1..86a160b 100644
--- a/src/protocols/flxbb/FlxbbDesign.cc
+++ b/src/protocols/flxbb/FlxbbDesign.cc
@@ -54,6 +54,7 @@
 #include <protocols/relax/ClassicRelax.hh>
 #include <protocols/relax/FastRelax.hh>
 #include <protocols/relax/RelaxProtocolBase.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 static basic::Tracer TR("protocols.flxbb.FlxbbDesign");
@@ -483,7 +484,7 @@ FlxbbDesign::build_design_taskset( Pose const & pose )
 /// @brief mover apply
 void FlxbbDesign::apply( pose::Pose & pose )
 {
-	using core::pose::switch_to_residue_type_set;
+	using protocols::toolbox::switch_to_residue_type_set;
 	using core::pack::task::PackerTaskOP;
 	using core::pack::task::TaskFactory;
 	using core::scoring::constraints::ConstraintSet;
@@ -496,7 +497,7 @@ void FlxbbDesign::apply( pose::Pose & pose )
 
 	// set pose to fullatom
 	if( ! pose.is_fullatom() ){
-		core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+		protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 	}
 
 	// set movemap from blueprint for relax
diff --git a/src/protocols/forge/components/BDR.cc b/src/protocols/forge/components/BDR.cc
index 6d09853..cd922d3 100644
--- a/src/protocols/forge/components/BDR.cc
+++ b/src/protocols/forge/components/BDR.cc
@@ -57,6 +57,7 @@
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
 #include <protocols/jumping/StrandPairing.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -272,7 +273,7 @@ bool BDR::centroid_build(
 	using core::scoring::ScoreFunctionFactory;
 	using protocols::moves::MS_SUCCESS;
 
-	using core::pose::switch_to_residue_type_set;
+	using protocols::toolbox::switch_to_residue_type_set;
 	using protocols::forge::methods::restore_residues;
 	using protocols::toolbox::pose_manipulation::construct_poly_ala_pose;
 
@@ -292,7 +293,7 @@ bool BDR::centroid_build(
 	}
 
 	if ( !mod_ap_is_full_atom ) {
-		core::pose::switch_to_residue_type_set( modified_archive_pose, core::chemical::FA_STANDARD );
+		protocols::toolbox::switch_to_residue_type_set( modified_archive_pose, core::chemical::FA_STANDARD );
 	}
 
 	// flip to poly-ala-gly-pro-disulf pose
diff --git a/src/protocols/forge/components/VarLengthBuild.cc b/src/protocols/forge/components/VarLengthBuild.cc
index 44c9d71..4b56b05 100644
--- a/src/protocols/forge/components/VarLengthBuild.cc
+++ b/src/protocols/forge/components/VarLengthBuild.cc
@@ -53,6 +53,7 @@
 //Auto Headers
 #include <core/fragment/FrameIterator.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 #ifdef WIN32
 #include <core/fragment/FragID.hh>
 #endif
@@ -209,7 +210,7 @@ void VarLengthBuild::apply( Pose & pose ) {
 	using protocols::moves::MS_SUCCESS;
 	using protocols::moves::FAIL_DO_NOT_RETRY;
 
-	using core::pose::switch_to_residue_type_set;
+	using protocols::toolbox::switch_to_residue_type_set;
 	using protocols::forge::methods::fold_tree_from_pose;
 	using protocols::forge::methods::restore_residues;
 
@@ -234,7 +235,7 @@ void VarLengthBuild::apply( Pose & pose ) {
 	if ( get_last_move_status() == MS_SUCCESS ) {
 		// alter residue type set if necessary
 		if ( pose.residue( 1 ).residue_type_set().name() != bi_rts_name ) {
-			core::pose::switch_to_residue_type_set( pose, bi_rts_name );
+			protocols::toolbox::switch_to_residue_type_set( pose, bi_rts_name );
 		}
 
 		// modify
@@ -260,7 +261,7 @@ void VarLengthBuild::apply( Pose & pose ) {
 	// centroid level protocol
 	if ( get_last_move_status() == MS_SUCCESS ) {
 		if ( pose.residue( 1 ).residue_type_set().name() != core::chemical::CENTROID ) {
-			core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+			protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 		}
 
 		if ( centroid_build( pose ) ) {
@@ -272,7 +273,7 @@ void VarLengthBuild::apply( Pose & pose ) {
 
 	// flip back to prior residue type set if necessary
 	if ( pose.residue( 1 ).residue_type_set().name() != archive_pose.residue( 1 ).residue_type_set().name() ) {
-		core::pose::switch_to_residue_type_set( pose, archive_pose.residue( 1 ).residue_type_set().name() );
+		protocols::toolbox::switch_to_residue_type_set( pose, archive_pose.residue( 1 ).residue_type_set().name() );
 	}
 
 	// recover side chains in fixed regions
diff --git a/src/protocols/forge/remodel/RemodelDesignMover.cc b/src/protocols/forge/remodel/RemodelDesignMover.cc
index 61522a0..1812453 100644
--- a/src/protocols/forge/remodel/RemodelDesignMover.cc
+++ b/src/protocols/forge/remodel/RemodelDesignMover.cc
@@ -25,7 +25,7 @@
 #include <core/util/MetricValue.hh>
 #include <core/conformation/Residue.hh>
 #include <core/scoring/disulfides/DisulfideMatchingPotential.hh>
-#include <core/pose/disulfide_util.hh>
+#include <protocols/toolbox/disulfide_util.hh>
 #include <core/conformation/util.hh>
 
 #include <core/scoring/ScoreFunction.hh>
@@ -452,7 +452,7 @@ void RemodelDesignMover::make_disulfide(Pose & pose, utility::vector1<std::pair<
 	//utility::vector1<std::pair<Size,Size>> dummy_vector;
 	for (utility::vector1<std::pair<Size,Size> >::iterator itr = disulf_partners.begin(); itr != disulf_partners.end(); itr++){
 		core::conformation::form_disulfide(pose.conformation(), (*itr).first, (*itr).second);
-		core::pose::rebuild_disulfide(pose, (*itr).first,(*itr).second);
+		protocols::toolbox::rebuild_disulfide(pose, (*itr).first,(*itr).second);
 	TR << "build_disulf between " << (*itr).first << " and " << (*itr).second << std::endl;
 	//	pose.dump_pdb("disulf.pdb");
 		}
diff --git a/src/protocols/forge/remodel/RemodelMover.cc b/src/protocols/forge/remodel/RemodelMover.cc
index 7c83a9f..7de1b2f 100644
--- a/src/protocols/forge/remodel/RemodelMover.cc
+++ b/src/protocols/forge/remodel/RemodelMover.cc
@@ -77,6 +77,7 @@
 //Auto Headers
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -329,8 +330,8 @@ void RemodelMover::apply( Pose & pose ) {
 	);
 
 //	manager_.dummy_modify(testArc.n_residue());
-//	core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID, true);
-//	core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD, true);
+//	protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID, true);
+//	protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD, true);
 //	protocols::forge::methods::restore_residues(manager_.original2modified(), testArc, pose);
 //	pose.dump_pdb("testArcRestore2.pdb");
 //	protocols::forge::methods::restore_residues(manager_.original2modified(), testArc, pose);
@@ -563,7 +564,7 @@ bool RemodelMover::centroid_build(
 	using namespace basic::options;
 	using protocols::moves::MS_SUCCESS;
 
-	using core::pose::switch_to_residue_type_set;
+	using protocols::toolbox::switch_to_residue_type_set;
 	using protocols::forge::methods::restore_residues;
 	//using protocols::toolbox::pose_manipulation::construct_poly_uniq_restype_pose;
 	using namespace protocols::forge::components;
@@ -584,7 +585,7 @@ bool RemodelMover::centroid_build(
 	}
 
 	if ( !mod_ap_is_full_atom ) {
-		core::pose::switch_to_residue_type_set( modified_archive_pose, core::chemical::FA_STANDARD );
+		protocols::toolbox::switch_to_residue_type_set( modified_archive_pose, core::chemical::FA_STANDARD );
 	}
 /*
 	// flip to poly-ala-gly-pro-disulf pose, only in the rebuilt segment
diff --git a/src/protocols/forge/remodel/RemodelWorkingSet.cc b/src/protocols/forge/remodel/RemodelWorkingSet.cc
index f8a3bfd..5955eba 100644
--- a/src/protocols/forge/remodel/RemodelWorkingSet.cc
+++ b/src/protocols/forge/remodel/RemodelWorkingSet.cc
@@ -93,6 +93,7 @@
 
 //Auto Headers
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -110,7 +111,7 @@ protocols::forge::remodel::WorkingRemodelSet::workingSetGen(
 	protocols::forge::remodel::RemodelData const & data
 )      {
 
-	//core::pose::switch_to_residue_type_set( input_pose, core::chemical::CENTROID );
+	//protocols::toolbox::switch_to_residue_type_set( input_pose, core::chemical::CENTROID );
 
 	//find rebuilding segments
 	int model_length = data.sequence.size();
diff --git a/src/protocols/init.cc b/src/protocols/init.cc
index c7ab17f..531e291 100644
--- a/src/protocols/init.cc
+++ b/src/protocols/init.cc
@@ -41,6 +41,7 @@
 /// Constraint creators
 #include <core/scoring/constraints/ConstraintFactory.hh>
 #include <protocols/constraints_additional/AdditionalConstraintCreators.hh>
+#include <protocols/constraints_additional/BindingSiteConstraint.hh>
 
 /// Mover creators
 #include <protocols/enzdes/AddOrRemoveMatchCstsCreator.hh>
@@ -188,6 +189,7 @@ static core::scoring::methods::EnergyMethodRegistrator< protocols::scoring::meth
 
 /// Constraint Registrators
 static core::scoring::constraints::ConstraintRegistrator< protocols::constraints_additional::SequenceProfileConstraintCreator > SequenceProfileConstraintCreator_registrator;
+static core::scoring::constraints::ConstraintRegistrator< protocols::constraints_additional::BindingSiteConstraintCreator > BindingSiteConstraintCreator_registrator;
 
 using namespace core::pack::task::operation;
 
diff --git a/src/protocols/jobdist/standard_mains.cc b/src/protocols/jobdist/standard_mains.cc
index 06a4ccb..1acdda4 100644
--- a/src/protocols/jobdist/standard_mains.cc
+++ b/src/protocols/jobdist/standard_mains.cc
@@ -77,6 +77,7 @@
 #include <core/import_pose/atom_tree_diffs/atom_tree_diff.hh>
 #include <core/pose/util.hh>
 #include <core/scoring/ScoreFunction.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 #include <utility/file/file_sys_util.hh>
 
 
@@ -416,7 +417,7 @@ int universal_main(
 							(option[ OptionKeys::score::weights ]() == "score_membrane"))
 			        && ( input_pose.is_fullatom() ) ) {
 					std::cout << "switching to centroid" << std::endl;
-					core::pose::switch_to_residue_type_set( input_pose, core::chemical::CENTROID );
+					protocols::toolbox::switch_to_residue_type_set( input_pose, core::chemical::CENTROID );
 				}
 
 				// are we a centroid scoring function but the input is fullatom ? )
@@ -424,7 +425,7 @@ int universal_main(
 //							(option[ OptionKeys::score::weights ]() == "standard") )
 //			        && ( !input_pose.is_fullatom() ) ) {
 //					std::cout << "switching to fullatom" << std::endl;
-//					core::pose::switch_to_residue_type_set( input_pose, core::chemical::STAMDARD );
+//					protocols::toolbox::switch_to_residue_type_set( input_pose, core::chemical::STAMDARD );
 //				}
 
 
diff --git a/src/protocols/loophash/LoopHashLibrary.cc b/src/protocols/loophash/LoopHashLibrary.cc
index 62a6427..c59933e 100644
--- a/src/protocols/loophash/LoopHashLibrary.cc
+++ b/src/protocols/loophash/LoopHashLibrary.cc
@@ -56,6 +56,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 #if defined(WIN32) || defined(__CYGWIN__)
@@ -318,7 +319,7 @@ namespace loophash {
       protocols::relax::FastRelax *relax = new protocols::relax::FastRelax( fascorefxn,  option[ OptionKeys::relax::sequence_file ]() );
 
       // convert pose to centroid pose:
-      core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID);
+      protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID);
       core::pose::set_ss_from_phipsi( pose );
 
       core::Size starttime2 = time(NULL);
diff --git a/src/protocols/loophash/MPI_LoopHashRefine.cc b/src/protocols/loophash/MPI_LoopHashRefine.cc
index c6e1ebf..d09ea82 100644
--- a/src/protocols/loophash/MPI_LoopHashRefine.cc
+++ b/src/protocols/loophash/MPI_LoopHashRefine.cc
@@ -55,6 +55,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 using namespace ObjexxFCL;
@@ -109,7 +110,7 @@ MPI_LoopHashRefine::set_defaults(){
 //		native_pose_ = new core::pose::Pose();
 //		core::import_pose::pose_from_pdb( *native_pose_, option[ in::file::native ]() );
 //		core::pose::set_ss_from_phipsi( *native_pose_ );
-//		core::pose::switch_to_residue_type_set( *native_pose_, core::chemical::CENTROID);
+//		protocols::toolbox::switch_to_residue_type_set( *native_pose_, core::chemical::CENTROID);
 //	}
 
 	// Make ident string:
@@ -141,7 +142,7 @@ MPI_LoopHashRefine::load_structures_from_cmdline_into_library( core::Size struct
 	while( input.has_another_pose() ) {
 		core::pose::Pose pose;
 		input.fill_pose( pose, *rsd_set );
-		//core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID);
+		//protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID);
 		core::pose::set_ss_from_phipsi( pose );
 		core::io::silent::ProteinSilentStruct pss;
 		pss.fill_struct( pose );
diff --git a/src/protocols/loophash/MPI_LoopHashRefine_Master.cc b/src/protocols/loophash/MPI_LoopHashRefine_Master.cc
index d3f2e06..d66756a 100644
--- a/src/protocols/loophash/MPI_LoopHashRefine_Master.cc
+++ b/src/protocols/loophash/MPI_LoopHashRefine_Master.cc
@@ -55,6 +55,7 @@
 
 //Auto Headers
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 using namespace ObjexxFCL;
@@ -235,7 +236,7 @@ MPI_LoopHashRefine_Master::create_loophash_WUs( const core::io::silent::SilentSt
 		runtime_assert( start_struct );
 		core::pose::Pose start_pose;
 		start_struct->fill_pose( start_pose );
-  	core::pose::switch_to_residue_type_set( start_pose, core::chemical::CENTROID);
+  	protocols::toolbox::switch_to_residue_type_set( start_pose, core::chemical::CENTROID);
 		core::pose::set_ss_from_phipsi( start_pose );
 
 		core::io::silent::ProteinSilentStruct pss;
diff --git a/src/protocols/loophash/WorkUnit_LoopHash.cc b/src/protocols/loophash/WorkUnit_LoopHash.cc
index 1f555e3..0f3684f 100644
--- a/src/protocols/loophash/WorkUnit_LoopHash.cc
+++ b/src/protocols/loophash/WorkUnit_LoopHash.cc
@@ -41,6 +41,7 @@
 
 //Auto Headers
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -119,7 +120,7 @@ WorkUnit_LoopHash::run()
 
 	// convert pose to centroid pose:
 	if( pose.is_fullatom() ){
-		core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID);
+		protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID);
 	}
 	core::pose::set_ss_from_phipsi( pose );
 
diff --git a/src/protocols/loops/LoopRelaxMover.cc b/src/protocols/loops/LoopRelaxMover.cc
index fff3831..16b7e61 100644
--- a/src/protocols/loops/LoopRelaxMover.cc
+++ b/src/protocols/loops/LoopRelaxMover.cc
@@ -101,6 +101,7 @@
 #include <protocols/relax/MiniRelax.hh>
 #include <protocols/relax/RelaxProtocolBase.hh>
 #include <protocols/relax/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 #include <numeric/random/random.fwd.hh>
 #include <basic/options/option.hh>
 
@@ -270,7 +271,7 @@ void LoopRelaxMover::apply( core::pose::Pose & pose ) {
 	);
 
 	if (fullatom_input) {
-		core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+		protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 	}
 
 
@@ -534,7 +535,7 @@ void LoopRelaxMover::apply( core::pose::Pose & pose ) {
 		TR << "Annotated sequence before fa switch: " << pose.annotated_sequence(true) << std::endl;
 
 		//puts full-atom sidechains on loop regions
-		core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+		protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 		pose.conformation().detect_bonds(); //apl fix this !
 
 		utility::vector1< bool > needToRepack( pose.total_residue() , !fullatom_input );
diff --git a/src/protocols/moves/SwitchResidueTypeSetMover.cc b/src/protocols/moves/SwitchResidueTypeSetMover.cc
index dd6614c..06bc9dc 100644
--- a/src/protocols/moves/SwitchResidueTypeSetMover.cc
+++ b/src/protocols/moves/SwitchResidueTypeSetMover.cc
@@ -26,6 +26,7 @@ static basic::Tracer TR("protocols.moves.SwitchResidueTypeSetMover");
 
 //Auto Headers
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 namespace protocols {
@@ -60,7 +61,7 @@ SwitchResidueTypeSetMover::SwitchResidueTypeSetMover( std::string const & type_s
 void
 SwitchResidueTypeSetMover::apply( Pose & pose )
 {
-	core::pose::switch_to_residue_type_set( pose, type_set_tag_ );
+	protocols::toolbox::switch_to_residue_type_set( pose, type_set_tag_ );
 }
 
 std::string
diff --git a/src/protocols/noesy_assign/CrossPeakList.cc b/src/protocols/noesy_assign/CrossPeakList.cc
index 4e87a49..cb16b35 100644
--- a/src/protocols/noesy_assign/CrossPeakList.cc
+++ b/src/protocols/noesy_assign/CrossPeakList.cc
@@ -47,6 +47,7 @@
 
 //Auto Headers
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 static basic::Tracer tr("devel.NoesyAssign.crosspeaks");
@@ -275,7 +276,7 @@ core::scoring::constraints::ConstraintSetOP CrossPeakList::generate_constraints(
 
 	if ( centroid ) {
 		centroid_pose = pose;
-		core::pose::switch_to_residue_type_set( centroid_pose, core::chemical::CENTROID );
+		protocols::toolbox::switch_to_residue_type_set( centroid_pose, core::chemical::CENTROID );
 		if ( tr.Debug.visible() ) {
 			centroid_pose.dump_pdb( "centroid_pose.pdb" );
 		}
diff --git a/src/protocols/noesy_assign/NoesyModule.cc b/src/protocols/noesy_assign/NoesyModule.cc
index de0d826..98fe7b1 100644
--- a/src/protocols/noesy_assign/NoesyModule.cc
+++ b/src/protocols/noesy_assign/NoesyModule.cc
@@ -117,6 +117,7 @@ using namespace util;
 
 //Auto Headers
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -201,7 +202,7 @@ void NoesyModule::generate_constraint_files(
 
 	using namespace core::scoring::constraints;
   core::pose::Pose centroid_pose = pose;
-  core::pose::switch_to_residue_type_set( centroid_pose, core::chemical::CENTROID );
+  protocols::toolbox::switch_to_residue_type_set( centroid_pose, core::chemical::CENTROID );
 
 	ConstraintSetOP cstset = new ConstraintSet;
 	ConstraintSetOP centroid_cstset = new ConstraintSet;
diff --git a/src/protocols/protein_interface_design/dock_design_filters.cc b/src/protocols/protein_interface_design/dock_design_filters.cc
index ee3c28c..3014e22 100644
--- a/src/protocols/protein_interface_design/dock_design_filters.cc
+++ b/src/protocols/protein_interface_design/dock_design_filters.cc
@@ -63,6 +63,7 @@
 //Auto Headers
 #include <core/chemical/ChemicalManager.fwd.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 #include <ObjexxFCL/format.hh>
 
 using namespace core;
@@ -219,12 +220,12 @@ ScoreTypeFilter::compute( core::pose::Pose const & pose ) const {
 				&& ( (*scorefxn_)[interchain_vdw] > 0.0 || (*scorefxn_)[vdw] > 0.0)  ) // a centroid term is on
 		{
 			if( in_pose->is_fullatom() ) { // but pose is full atom
-			core::pose::switch_to_residue_type_set( *in_pose, core::chemical::CENTROID );
+			protocols::toolbox::switch_to_residue_type_set( *in_pose, core::chemical::CENTROID );
 		}
 	}
 	else { // full atom case
 		if( in_pose->is_centroid() ) { // but pose is centroid
-			core::pose::switch_to_residue_type_set( *in_pose, core::chemical::FA_STANDARD );
+			protocols::toolbox::switch_to_residue_type_set( *in_pose, core::chemical::FA_STANDARD );
 		}
 	}
 
@@ -893,12 +894,12 @@ EnergyPerResidueFilter::compute( core::pose::Pose const & pose ) const
 		&& ( (*scorefxn_)[fa_atr] == 0.0 ) )
 		{
 			if( in_pose.is_fullatom() ) {
-			core::pose::switch_to_residue_type_set( in_pose, core::chemical::CENTROID );
+			protocols::toolbox::switch_to_residue_type_set( in_pose, core::chemical::CENTROID );
 		}
 	}
 	else {
 		if( in_pose.is_centroid() ) {
-			core::pose::switch_to_residue_type_set( in_pose, core::chemical::FA_STANDARD );
+			protocols::toolbox::switch_to_residue_type_set( in_pose, core::chemical::FA_STANDARD );
 		}
 	}
 
diff --git a/src/protocols/protein_interface_design/movers/DisulfideMover.cc b/src/protocols/protein_interface_design/movers/DisulfideMover.cc
index 89ce05e..8791161 100644
--- a/src/protocols/protein_interface_design/movers/DisulfideMover.cc
+++ b/src/protocols/protein_interface_design/movers/DisulfideMover.cc
@@ -40,7 +40,7 @@
 #include <core/scoring/ScoreFunction.hh>
 // Auto-header: duplicate removed #include <core/scoring/Energies.hh>
 
-#include <core/pose/disulfide_util.hh>
+#include <protocols/toolbox/disulfide_util.hh>
 
 //get_resnum crap
 
@@ -214,7 +214,7 @@ void DisulfideMover::apply( Pose & pose ) {
 		}
 
 		// Form disulfide bond
-		core::pose::rebuild_disulfide(*trial_pose,disulf->first, disulf->second,
+		protocols::toolbox::rebuild_disulfide(*trial_pose,disulf->first, disulf->second,
 			task_, scorefxn_repack_, mm, scorefxn_minimize_);
 
 		std::string name = trial_pose->residue(disulf->first).name();
diff --git a/src/protocols/protein_interface_design/movers/LoopRemodel.cc b/src/protocols/protein_interface_design/movers/LoopRemodel.cc
index 834df6d..b5719f9 100644
--- a/src/protocols/protein_interface_design/movers/LoopRemodel.cc
+++ b/src/protocols/protein_interface_design/movers/LoopRemodel.cc
@@ -75,6 +75,7 @@
 #include <core/fragment/FrameIterator.hh>
 #include <core/pose/util.hh>
 #include <protocols/moves/MonteCarlo.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 
@@ -265,7 +266,7 @@ LoopRemodel::apply( core::pose::Pose & pose )
 			//protocols::moves::MonteCarlo mc( pose, *scorefxn_repack_, mc_kt );
 			SaveAndRetrieveSidechains retrieve_sc( pose );
 			retrieve_sc.allsc( true );
-			core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID);
+			protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID);
 			if( protocol_ == "kinematic" ) {
 				if( perturb_ ) {
 					for( Loops::iterator it = loops->v_begin(); it != loops->v_end(); ++it ) {
@@ -275,7 +276,7 @@ LoopRemodel::apply( core::pose::Pose & pose )
 					perturb.set_native_pose( new core::pose::Pose ( native_pose ) );
 					perturb.apply( pose );
 				}
-				core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+				protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 				retrieve_sc.apply( pose ); // recover sidechains from pre-centroid pose
 				if( refine_ ) {
 					protocols::loops::LoopMover_Refine_KIC refine( *loops, hires_score_ );
@@ -312,7 +313,7 @@ LoopRemodel::apply( core::pose::Pose & pose )
 					perturb.set_native_pose( new core::pose::Pose ( native_pose ) );
 					perturb.apply( pose );
 				}
-				core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+				protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 				retrieve_sc.apply( pose ); // recover sidechains from pre-centroid pose
 				if( refine_ ) {
 					protocols::loops::LoopMover_Refine_CCD refine( *loops, hires_score_ );
@@ -327,7 +328,7 @@ LoopRemodel::apply( core::pose::Pose & pose )
 			} // protocol == ccd
 			else if( protocol_ == "remodel" ) {
 				// remodel starts as fa
-				core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+				protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 				retrieve_sc.apply( pose ); // recover sidechains from pre-centroid pose
 
 				core::scoring::dssp::Dssp dssp( pose );
diff --git a/src/protocols/rbsegment_moves/RBSegmentRelax_main.cc b/src/protocols/rbsegment_moves/RBSegmentRelax_main.cc
index fa10707..8b07f6f 100644
--- a/src/protocols/rbsegment_moves/RBSegmentRelax_main.cc
+++ b/src/protocols/rbsegment_moves/RBSegmentRelax_main.cc
@@ -79,9 +79,10 @@
 #include <core/chemical/ChemicalManager.fwd.hh>
 #include <core/conformation/Residue.hh>
 #include <core/io/silent/SilentStruct.hh>
-#include <basic/options/option.hh>
 #include <core/pose/util.hh>
 #include <protocols/rbsegment_moves/RBSegment.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
+#include <basic/options/option.hh>
 
 
 
@@ -140,7 +141,7 @@ RBSegmentRelax_main( bool boinc_mode ) {
     boinc::Boinc::set_graphics_native_pose( native_pose );
 #endif
 
-		core::pose::switch_to_residue_type_set( native_pose, core::chemical::CENTROID );
+		protocols::toolbox::switch_to_residue_type_set( native_pose, core::chemical::CENTROID );
 	}
 
 	// Read RB segs, auto generate loops
@@ -194,7 +195,7 @@ RBSegmentRelax_main( bool boinc_mode ) {
 
 		pose = start_pose;
 //		if ( option[ in::file::fullatom ]() )
-//			core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+//			protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 
 #ifdef BOINC_GRAPHICS
 	// attach boinc graphics pose observer
diff --git a/src/protocols/relax/FastRelax.cc b/src/protocols/relax/FastRelax.cc
index 39224b1..df8a1b1 100644
--- a/src/protocols/relax/FastRelax.cc
+++ b/src/protocols/relax/FastRelax.cc
@@ -184,6 +184,7 @@ endrepeat
 
 //Auto Headers
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 #include <utility/string_util.hh>
 #include <utility/io/mpistream.hh>
 #include <fstream>
@@ -430,7 +431,7 @@ void FastRelax::apply( core::pose::Pose & pose ){
 	// wont be properly packed at this stage but it doesnt really matter.
 	// They'll get repacked shortly.
 	if( !pose.is_fullatom() ){
-		core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD);
+		protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD);
 	}
 
 	// Make a local copy of movemap, called local movemap. The reason is that
@@ -850,7 +851,7 @@ void FastRelax::batch_apply(  std::vector < SilentStructOP > & input_structs ){
 		// 432mb
 		if( !pose.is_fullatom() ){
 			TR.Debug << "Switching struct to fullatom" << std::endl;
-			core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD);
+			protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD);
 			//core::Real afterscore = (*local_scorefxn)(pose);
 		}
 		// 453mb
diff --git a/src/protocols/relax/MiniRelax.cc b/src/protocols/relax/MiniRelax.cc
index d0a9288..e75d015 100644
--- a/src/protocols/relax/MiniRelax.cc
+++ b/src/protocols/relax/MiniRelax.cc
@@ -40,6 +40,7 @@
 
 //Auto Headers
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 static basic::Tracer TR("protocols.relax.MiniRelax");
@@ -71,7 +72,7 @@ MiniRelax::clone() const {
 ////////////////////////////////////////////////////////////////////////////////////////////////////
 void MiniRelax::apply( core::pose::Pose & pose ) {
 	if ( !pose.is_fullatom() ) {
-		core::pose::switch_to_residue_type_set(
+		protocols::toolbox::switch_to_residue_type_set(
 			pose, core::chemical::FA_STANDARD
 		);
 		std::cerr << "Fullatom mode .... " << std::endl;
diff --git a/src/protocols/scoring/methods/saxs/PDDFEnergy.cc b/src/protocols/scoring/methods/saxs/PDDFEnergy.cc
index 4bba143..92cc17d 100644
--- a/src/protocols/scoring/methods/saxs/PDDFEnergy.cc
+++ b/src/protocols/scoring/methods/saxs/PDDFEnergy.cc
@@ -53,6 +53,7 @@
 //Auto Headers
 #include <core/import_pose/import_pose.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 namespace protocols {
@@ -139,7 +140,7 @@ PDDFEnergy::PDDFEnergy() : WholeStructureEnergy( new PDDFEnergyCreator ) {
 	    core::import_pose::pose_from_pdb(reference_pose, *rsd_set,
 		basic::options::option[in::file::native]());
 
-	    core::pose::switch_to_residue_type_set( reference_pose, core::chemical::CENTROID );
+	    protocols::toolbox::switch_to_residue_type_set( reference_pose, core::chemical::CENTROID );
 
 	    create_pddf( reference_pose,min_d,bin_d,max_d );
     	    min_bin_ = (core::Size)(min_d / bin_size_);  //These should be static casts not c style casts
diff --git a/src/protocols/swa/StepWiseScreener.cc b/src/protocols/swa/StepWiseScreener.cc
index c6e1a2c..a29ed63 100644
--- a/src/protocols/swa/StepWiseScreener.cc
+++ b/src/protocols/swa/StepWiseScreener.cc
@@ -52,6 +52,7 @@
 //Auto Headers
 #include <core/pose/annotated_sequence.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 using namespace core;
@@ -282,7 +283,7 @@ namespace swa {
 		core::pose::remove_variant_type_from_pose_residue( pose, "C_METHYLAMIDATION", pose.total_residue() );
 		core::pose::add_variant_type_to_pose_residue( pose, "UPPER_TERMINUS", pose.total_residue() );
 
-		core::pose::switch_to_residue_type_set( pose, core::chemical::CENTROID );
+		protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::CENTROID );
 
 		// get DSSP, assign secondary structure
 		protocols::jumping::Dssp dssp_obj( pose );
diff --git a/src/protocols/toolbox/SwitchResidueTypeSet.cc b/src/protocols/toolbox/SwitchResidueTypeSet.cc
new file mode 100644
index 0000000..5d13d1c
--- /dev/null
+++ b/src/protocols/toolbox/SwitchResidueTypeSet.cc
@@ -0,0 +1,199 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 sw=2 noet:
+//
+// This file is part of the Rosetta software suite and is made available under license.
+// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
+// (C) 199x-2009 Rosetta Commons participating institutions and developers.
+// For more information, see http://www.rosettacommons.org/.
+
+/// @file protocols/toolbox/SwitchResidueTypeSet.cc
+/// @brief Functions for switching the residue type set of a pose
+/// @author P. Douglas Renfrew (renfrew@nyu.edu)
+
+// Unit Headers
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
+
+// Project Headers
+#include <core/chemical/ResidueType.hh>
+#include <core/chemical/ResidueTypeSet.hh>
+#include <core/chemical/ChemicalManager.hh>
+
+#include <core/conformation/Conformation.hh>
+#include <core/conformation/ResidueFactory.hh>
+#include <core/conformation/util.hh>
+
+#include <core/pose/Pose.hh>
+
+#include <core/scoring/ScoreType.hh>
+#include <core/scoring/ScoreFunction.hh>
+#include <core/scoring/Energies.hh>
+
+#include <core/kinematics/MoveMap.hh>
+
+#include <core/pack/task/TaskFactory.hh>
+#include <core/pack/task/PackerTask.hh>
+
+#include <protocols/toolbox/disulfide_util.hh>
+
+// Basic Headers
+#include <basic/Tracer.hh>
+
+// Option Headers
+#include <basic/options/option.hh>
+#include <basic/options/keys/in.OptionKeys.gen.hh>
+#include <basic/options/keys/run.OptionKeys.gen.hh>
+
+//Auto Headers
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
+
+
+namespace protocols {
+namespace toolbox {
+
+static basic::Tracer TR("protocols.toolbox.switchresiduetypeset");
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////
+///@details the function allows a pose to use a different residue_type_set to represent all its residues,
+///such as from fullatom residues to centroid residues, or vice versa. During the switch, corresponding atoms
+///will be copied. Redundant atoms will be removed (in case from fullatom to centroid) and missing atoms will be
+///built by ideal geometry (in the case from centroid to fullatom).
+void
+switch_to_residue_type_set(
+	core::pose::Pose & pose,
+	std::string const & type_set_name,
+	bool allow_sloppy_match
+	)
+{
+	using namespace core::chemical;
+	using namespace core::conformation;
+	using namespace std;
+	using utility::vector1;
+
+	//SML 04/06/09
+	//Energies object is not properly "aware" of typeset changes, and can attempt to score your pose with an incompatible
+	//scorefunction if you go FA->CEN (or vice versa) and access the Energies without rescoring.
+	//So, we'll eject the Energies to be safe!
+	pose.energies().clear();
+
+
+	// retrieve proper residue_type_set
+	core::chemical::ResidueTypeSetCAP target_residue_type_set( core::chemical::ChemicalManager::get_instance()->residue_type_set( type_set_name ) );
+	// loop each position and find new type that matches from the new type set
+	for ( core::Size i=1; i<= pose.total_residue(); ++i ) {
+		core::conformation::Residue const & rsd( pose.residue(i) );
+		// in future we may have a conformation using mixed type set, so check this by residue
+		std::string const & current_type_set_name ( rsd.type().residue_type_set().name() ); // database_directory() );
+		if ( current_type_set_name == type_set_name ) {
+			TR.Warning << "protocols::toolbox::switch_to_residue_type_set: residue " << i << " already in " << type_set_name
+			<< " residue_type_set" << std::endl;
+			continue;
+		}
+
+		// get all residue types with same AA
+
+		core::conformation::ResidueOP new_rsd( 0 );
+		if( ( rsd.aa() == aa_unk ) || ( rsd.name().substr(0,5) == "HIS_D" ) ){
+			// ligand or metal ions are all defined as "UNK" AA, so check a rsdtype with same name
+			// for HIS_D tautomer, we want to keep its tautomer state
+			core::chemical::ResidueTypeCAPs const & rsd_types( target_residue_type_set->name3_map( rsd.name3() ) );
+			for (core::Size j=1; j<=rsd_types.size(); ++j ) {
+				core::chemical::ResidueType const & new_rsd_type( *rsd_types[j] );
+				if ( rsd.type().name() == new_rsd_type.name() ) {
+					new_rsd = core::conformation::ResidueFactory::create_residue( new_rsd_type, rsd, pose.conformation() );
+					break;
+				}
+			}
+		} else  {
+			// for a normal AA/DNA/RNA residue, now look for a rsdtype with same variants
+			core::chemical::ResidueTypeCAPs const & rsd_types( target_residue_type_set->name3_map( rsd.name().substr(0,3) ) );
+			for ( core::Size j=1; j<= rsd_types.size(); ++j ) {
+				core::chemical::ResidueType const & new_rsd_type( *rsd_types[j] );
+				if ( rsd.type().variants_match( new_rsd_type ) ) {
+					new_rsd = core::conformation::ResidueFactory::create_residue( new_rsd_type, rsd, pose.conformation() );
+					break;
+				}
+			}
+			if ( allow_sloppy_match ){
+				if ( ! new_rsd ) {
+					TR.Warning << "Did not find perfect match for residue: "  << rsd.name()
+					<< "at position " << i << ". Trying to find acceptable match. " << std::endl;
+					for ( core::Size j=1; j<= rsd_types.size(); ++j ) {
+						core::chemical::ResidueType const & new_rsd_type( *rsd_types[j] );
+						if ( rsd.type().name3()  == new_rsd_type.name3()  ) {
+							new_rsd = core::conformation::ResidueFactory::create_residue( new_rsd_type, rsd, pose.conformation() );
+							break;
+						}
+					}
+					if (  new_rsd ) {
+						TR.Warning << "Found an acceptable match: " << rsd.type().name() << " --> " << new_rsd->name() << std::endl;
+					}
+				}
+			}
+		}
+
+		if ( ! new_rsd ) {
+			std::cerr << pose.sequence() << std::endl;
+			std::cerr  << "can not find a residue type that matches the residue " << rsd.name()
+			<< "at position " << i << std::endl;
+			utility_exit_with_message( "protocols::toolbox::switch_to_residue_type_set fails\n" );
+		}
+		// switch to corresponding residue type in the new set.
+		if ( !rsd.is_protein() ) {
+			// rethink this logic, phil
+			TR.Debug << "trying to preserve existing coords for non-protein residue: " << rsd.seqpos() << ' ' << rsd.name() << std::endl;
+			core::conformation::copy_residue_coordinates_and_rebuild_missing_atoms( rsd, *new_rsd, pose.conformation() );
+		}
+		pose.replace_residue( i, *new_rsd, false );
+	}
+
+	// After a CEN->FA transition, rebuild the disulfides
+	if(pose.is_fullatom() && basic::options::option[ basic::options::OptionKeys::run::rebuild_disulf ]() ) {
+		vector1<pair<core::Size,core::Size> > disulfides;
+		core::conformation::disulfide_bonds(pose.conformation(), disulfides);
+		
+		if( disulfides.size() > 0 ) {
+			// Setup Packer & Minimizer
+			core::pack::task::PackerTaskOP task = core::pack::task::TaskFactory::create_packer_task( pose );
+			task->initialize_from_command_line().or_include_current( true );
+			task->restrict_to_repacking();
+
+			core::kinematics::MoveMapOP mm(new core::kinematics::MoveMap);
+			mm->set_bb( false );
+
+			// Set up each residue individually
+			for( core::Size i(1); i <= pose.total_residue(); ++i )
+			{
+				core::conformation::Residue const& res(pose.residue(i));
+				if( !res.is_protein() )
+					continue;
+
+				// Determine if i is part of disulfides
+				bool is_disulf = false;
+				for(vector1<pair<core::Size, core::Size> >::const_iterator
+					disulf(disulfides.begin()), end_disulf(disulfides.end());
+					disulf != end_disulf; ++disulf)
+				{
+					if( i == disulf->first || i == disulf->second ) {
+						is_disulf = true;
+						break;
+					}
+				}
+
+				if( is_disulf ) {
+					// repack & minimize disulfides
+					mm->set_chi(i, true);
+				} else {
+					// Other residues are unchanged
+					task->nonconst_residue_task(i).prevent_repacking();
+				}
+			}
+
+			// Rebuild disulfides
+			protocols::toolbox::rebuild_disulfide(pose, disulfides, task, NULL, mm, NULL);
+		}
+	}
+}// protocols::toolbox::switch_to_residue_type_set
+
+
+} // toolbox
+} // protocols
diff --git a/src/protocols/toolbox/SwitchResidueTypeSet.hh b/src/protocols/toolbox/SwitchResidueTypeSet.hh
new file mode 100644
index 0000000..6e1fd71
--- /dev/null
+++ b/src/protocols/toolbox/SwitchResidueTypeSet.hh
@@ -0,0 +1,43 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 sw=2 noet:
+//
+// This file is part of the Rosetta software suite and is made available under license.
+// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
+// (C) 199x-2009 Rosetta Commons participating institutions and developers.
+// For more information, see http://www.rosettacommons.org/.
+
+/// @file protocols/toolbox/SwitchResidueTypeSet.hh
+/// @brief Functions for switching the residue type set of a pose
+/// @author P. Douglas Renfrew (renfrew@nyu.edu)
+
+#ifndef INCLUDED_protocols_toolbox_switchresiduetypeset_HH
+#define INCLUDED_protocols_toolbox_switchresiduetypeset_HH
+
+// Unit headers
+#include <core/pose/Pose.hh>
+
+//Auto Headers
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
+
+namespace protocols {
+namespace toolbox {
+
+
+/// @details the function allows a pose to use a different residue_type_set to
+/// represent all its residues, such as from fullatom residues to centroid
+/// residues, or vice versa. During the switch, corresponding atoms will be
+/// copied. Redundant atoms will be removed (in case from fullatom to centroid)
+/// and missing atoms will be built by ideal geometry (in the case from centroid
+/// to fullatom).
+void
+switch_to_residue_type_set(
+	core::pose::Pose & pose,
+	std::string const & type_set_name,
+	bool allow_sloppy_match = false
+	);
+
+} // toolbox
+} // protocols
+
+#endif //INCLUDED_protocols_toolbox_switchresiduetypeset_HH
+
diff --git a/src/protocols/toolbox/disulfide_util.cc b/src/protocols/toolbox/disulfide_util.cc
index 80ade2a..8185376 100644
--- a/src/protocols/toolbox/disulfide_util.cc
+++ b/src/protocols/toolbox/disulfide_util.cc
@@ -43,7 +43,7 @@
 #include <basic/Tracer.hh>
 
 // Utility Headers
-// AUTO-REMOVED #include <utility/vector1.hh>
+#include <utility/vector1.hh>
 
 // C++ headers
 // AUTO-REMOVED #include <utility>
@@ -52,8 +52,8 @@
 #include <core/chemical/VariantType.hh>
 
 
-namespace core {
-namespace chemical {
+namespace protocols {
+namespace toolbox {
 
 using namespace core;
 using namespace std;
@@ -66,104 +66,12 @@ using core::pack::task::PackerTaskOP;
 using core::scoring::ScoreFunctionOP;
 using core::kinematics::MoveMap;
 using core::kinematics::MoveMapOP;
-static basic::Tracer TR( "core.chemical.disulfide_util" );
-
-
-/// @brief Introduce cysteines at the specified location and define a
-///  disulfide bond between them.
-/// @details Does not do the repacking & minimization required to place the
-///  disulfide correctly.
-void protocols::toolbox::form_disulfide(Pose & pose, Size lower_res, Size upper_res)
-{
-	// Verify we're dealing with a FA pose
-	runtime_assert( pose.is_fullatom() );
-
-	ResidueTypeSetCAP restype_set =
-		ChemicalManager::get_instance()->residue_type_set( FA_STANDARD );
-
-	// Break existing disulfide bonds to lower
-	if( pose.residue(lower_res).aa() == chemical::aa_cys &&
-			pose.residue( lower_res ).has_variant_type( chemical::DISULFIDE ) &&
-			pose.residue_type( lower_res ).has_atom_name( "SG" ) // full atom residue
-			)
-	{
-		Size const connect_atom( pose.residue( lower_res ).atom_index( "SG" ) );
-		Size other_res( 0 );
-		Size conn(0);
-		for ( conn = pose.residue( lower_res ).type().n_residue_connections(); conn >= 1; --conn ) {
-			if( Size( pose.residue(lower_res).type().residue_connection(conn).atomno() ) == connect_atom ) {
-				other_res = pose.residue( lower_res ).connect_map( conn ).resid();
-				break;
-			}
-		}
-		if ( other_res == 0 ) {
-			TR.Error << "Error: Residue " << lower_res << " was disulfide bonded but had no partner" << std::endl;
-			utility_exit();
-		}
-
-		if(other_res == upper_res) {
-			// Already a disulfide bond
-			runtime_assert_msg(pose.residue( upper_res ).connect_map( conn ).resid() == lower_res,
-				"Error: Disulfide bond wasn't reciprical");
-			return;
-		}
-
-		// Break the disulfide bond to upper_res
-		bool result = change_cys_state( other_res, "CYS", pose.conformation() );
-		runtime_assert_msg(result,"Error converting CYD->CYS");
-	}
-	else {
-		ResidueOP lower_cyd = ResidueFactory::create_residue(
-			restype_set->name_map("CYD"), pose.residue(lower_res),
-			pose.conformation());
-		copy_residue_coordinates_and_rebuild_missing_atoms(
-			pose.residue(lower_res), *lower_cyd, pose.conformation() );
-		pose.replace_residue(lower_res, *lower_cyd, false /*backbone already oriented*/);
-	}
-	// Break existing disulfide bonds to upper
-	if( pose.residue(upper_res).aa() == chemical::aa_cys &&
-			pose.residue( upper_res ).has_variant_type( chemical::DISULFIDE ) &&
-			pose.residue_type( upper_res ).has_atom_name( "SG" ) // full atom residue
-			)
-	{
-		Size const connect_atom( pose.residue( upper_res ).atom_index( "SG" ) );
-		Size other_res( 0 );
-		Size conn(0);
-		for ( conn = pose.residue( upper_res ).type().n_residue_connections(); conn >= 1; --conn ) {
-			if( Size( pose.residue(upper_res).type().residue_connection(conn).atomno() ) == connect_atom ) {
-				other_res = pose.residue( upper_res ).connect_map( conn ).resid();
-				break;
-			}
-		}
-		if ( other_res == 0 ) {
-			TR.Warning << "Warning: Residue " << upper_res << " was disulfide bonded but had no partner" << std::endl;
-			utility_exit();
-		}
-
-		// Break the disulfide bond to lower_res
-		bool result = change_cys_state( other_res, "CYS", pose.conformation());
-		runtime_assert_msg(result,"Error converting CYD->CYS");
-	}
-	else {
-		ResidueOP upper_cyd = ResidueFactory::create_residue(
-			restype_set->name_map("CYD"), pose.residue(upper_res),
-			pose.conformation());
-		copy_residue_coordinates_and_rebuild_missing_atoms(
-			pose.residue(upper_res), *upper_cyd, pose.conformation() );
-		pose.replace_residue(upper_res, *upper_cyd, false /*backbone already oriented*/);
-	}
-
-	// Both residues are now CYD
-	runtime_assert(pose.residue(lower_res).name() == "CYD" && pose.residue(upper_res).name() == "CYD" );
-
-	//form the bond between the two residues
-	pose.conformation().declare_chemical_bond(lower_res,"SG",upper_res,"SG");
-
-}
+static basic::Tracer TR( "protocols.toolbox.disulfide_util" );
 
 /// @details A convenience function for calling \c protocols::toolbox::rebuild_disulfide() with
 ///  only a single disulfide bond
-void protocols::toolbox::rebuild_disulfide( Pose & pose, Size lower_res, Size upper_res,
+void
+rebuild_disulfide( Pose & pose, Size lower_res, Size upper_res,
 		PackerTaskOP packer_task, ScoreFunctionOP packer_score,
 		MoveMapOP mm, ScoreFunctionOP minimizer_score )
 {
@@ -195,7 +103,8 @@ void protocols::toolbox::rebuild_disulfide( Pose & pose, Size lower_res, Size up
 ///  of freedom if ommitted or NULL.
 /// @param minimizer_score[in] The score to use for minimization. Defaults to
 ///  packer_score if ommitted or NULL.
-void protocols::toolbox::rebuild_disulfide( core::pose::Pose & pose,
+void
+rebuild_disulfide( core::pose::Pose & pose,
 	utility::vector1<std::pair<core::Size, core::Size> > disulfides,
 	core::pack::task::PackerTaskOP packer_task,
 	core::scoring::ScoreFunctionOP packer_score,
@@ -216,7 +125,7 @@ void protocols::toolbox::rebuild_disulfide( core::pose::Pose & pose,
 		is_disulf[disulf->second] = true;
 
 		// Verify precondition
-		if( ! protocols::toolbox::is_disulfide_bond(pose, disulf->first, disulf->second) ) {
+		if( ! core::conformation::is_disulfide_bond(pose.conformation(), disulf->first, disulf->second) ) {
 			TR.Error << "Disulfide bond required between " << disulf->first
 				<< " and " << disulf->second << "." << std::endl;
 			utility_exit();
@@ -263,7 +172,7 @@ void protocols::toolbox::rebuild_disulfide( core::pose::Pose & pose,
 	}
 
 	// REPACK
-	static_cast<*packer_score>(pose); // structure must be scored before rotamer_trials can be called
+	(*packer_score)(pose); // structure must be scored before rotamer_trials can be called
 	pack::pack_rotamers(pose, *packer_score, packer_task );
 
 	using namespace core::optimization;
@@ -272,86 +181,8 @@ void protocols::toolbox::rebuild_disulfide( core::pose::Pose & pose,
 
 	// update score
 	pose.update_residue_neighbors();
-	static_cast<*minimizer_score>( pose );
-
-}
-
-/// @brief Find whether there is a disulfide defined between two residues
-///
-/// @details We define a disulfide to exist between a pair of residues iff
-///  -# They are both cysteines
-///  -# They are bonded by their sidechains
-bool
-protocols::toolbox::is_disulfide_bond( pose::Pose const& pose, Size residueA_pos, Size residueB_pos)
-{
-	Residue const& A = pose.residue(residueA_pos);
-	Residue const& B = pose.residue(residueB_pos);
-
-	if( !A.is_protein() || !B.is_protein() )
-		return false;
-
-	//both Cys or CysD
-	if( A.type().name1() != 'C' || B.type().name1() != 'C' )
-		return false;
-
-	//bonded
-	Size a_connect_atom;
-	if( A.type().has_atom_name( "SG" ) )
-		a_connect_atom = A.atom_index( "SG" );
-	else {
-		runtime_assert( A.type().has_atom_name( "CEN" ) ); //should be fa or centroid
-		a_connect_atom = A.atom_index( "CEN" );
-	}
-	for ( Size connection = A.type().n_residue_connections(); connection >= 1; --connection ) {
-		//check if A bonded to B
-		if ( (Size) A.type().residue_connection( connection ).atomno() == a_connect_atom && //bond to sg, not the backbone
-				A.connect_map( connection ).resid() == residueB_pos ) { //bonded to B
-			return true;
-		}
-	}
-
-	return false;
-}
-
-/// @brief Generate a list of all disulfide bonds in the pose
-void protocols::toolbox::disulfide_bonds( pose::Pose const& pose, vector1< pair<Size,Size> > & disulfides )
-{
-	for( Size i=1; i<= pose.total_residue(); ++i)
-	{
-		Residue const& res(pose.residue(i));
+	(*minimizer_score)( pose );
 
-		// Skip things besides CYD
-		if( !(res.aa() == aa_cys && res.has_variant_type(chemical::DISULFIDE) ))
-			continue;
-		Size connect_atom( 0);
-		if( res.type().has_atom_name( "SG" ))
-			connect_atom = res.atom_index( "SG" );
-		else if( res.type().has_atom_name( "CEN" ))
-			connect_atom = res.atom_index( "CEN" );
-		else {
-			TR.Warning << "Warning: unable to establish which atom to use for the disulfide to residue "
-				<< i << std::endl;
-			continue;
-		}
-
-		Size other_res(0);
-		Size conn;
-		for( conn = pose.residue( i ).type().n_residue_connections(); conn >= 1; --conn ) {
-			if( Size( pose.residue( i ).type().residue_connection(conn).atomno() ) == connect_atom ) {
-				other_res = pose.residue( i ).connect_map( conn ).resid();
-				break;
-			}
-		}
-		if ( other_res == 0 ) {
-			TR.Error << "Error: Residue " << i << " was disulfide bonded but had no partner" << std::endl;
-			utility_exit();
-		}
-
-		// Output the pair once
-		if( i < other_res ) {
-			disulfides.push_back( std::make_pair(i, other_res) );
-		}
-	}
 }
 
 } // ProteinInterfaceDesign
diff --git a/src/protocols/toolbox/disulfide_util.hh b/src/protocols/toolbox/disulfide_util.hh
index 7413f73..78d3564 100644
--- a/src/protocols/toolbox/disulfide_util.hh
+++ b/src/protocols/toolbox/disulfide_util.hh
@@ -48,11 +48,6 @@
 namespace protocols {
 namespace toolbox {
 
-/// @brief Introduce cysteines at the specified location and define a
-///  disulfide bond between them.
-/// @details Does not do the repacking & minimization required to place the
-///   disulfide correctly.
-void form_disulfide(core::pose::Pose & pose, core::Size lower_res, core::Size upper_res);
 
 /// @brief Rebuild a pair of cysteines (and possibly surrounding residues) so
 ///  that they form a near-ideal disulfide bond
@@ -72,14 +67,6 @@ void rebuild_disulfide( core::pose::Pose & pose,
 	core::kinematics::MoveMapOP mm = 0,
 	core::scoring::ScoreFunctionOP minimizer_score = 0 );
 
-/// @brief Find whether there is a disulfide defined between two residues
-bool is_disulfide_bond( core::pose::Pose const& pose,
-	core::Size residueA_pos, core::Size residueB_pos);
-
-/// @brief Generate a list of all disulfide bonds in the pose
-void disulfide_bonds( core::pose::Pose const& pose,
-	utility::vector1< std::pair<core::Size,core::Size> > & disulfides );
-
 } // chemical
 } // core
 
diff --git a/src/protocols/toolbox/pose_metric_calculators/FragQualCalculator.cc b/src/protocols/toolbox/pose_metric_calculators/FragQualCalculator.cc
index 1a154cc..3809793 100644
--- a/src/protocols/toolbox/pose_metric_calculators/FragQualCalculator.cc
+++ b/src/protocols/toolbox/pose_metric_calculators/FragQualCalculator.cc
@@ -41,6 +41,7 @@
 
 //Auto Headers
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 
 
 static basic::Tracer TR("protocols.toolbox.PoseMetricCalculators.FragQualCalculator");
@@ -186,8 +187,8 @@ FragQualCalculator::recompute( Pose const & pose )
 	utility::vector1< bool > is_covered( pose.total_residue(), false );
 
 	Pose input_pose( pose ), test_pose( pose );
-	core::pose::switch_to_residue_type_set( input_pose, core::chemical::CENTROID );
-	core::pose::switch_to_residue_type_set(  test_pose, core::chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set( input_pose, core::chemical::CENTROID );
+	protocols::toolbox::switch_to_residue_type_set(  test_pose, core::chemical::CENTROID );
 
 	for ( FrameIterator frame = frag_->begin(); frame != frag_->end(); ++frame ) {
 
diff --git a/src/protocols/topology_broker/RigidChunkClaimer.cc b/src/protocols/topology_broker/RigidChunkClaimer.cc
index 45533f3..5532121 100644
--- a/src/protocols/topology_broker/RigidChunkClaimer.cc
+++ b/src/protocols/topology_broker/RigidChunkClaimer.cc
@@ -59,6 +59,8 @@
 #include <core/import_pose/import_pose.hh>
 #include <basic/options/option.hh>
 #include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
+#include <basic/options/option.hh>
 
 
 // option key includes
@@ -115,7 +117,7 @@ RigidChunkClaimer::RigidChunkClaimer( pose::Pose const& input_pose, loops::Loops
 	bUseInputPose_( true ),
 	bRigidInRelax_( false )
 {
-	if ( centroid_input_pose_.total_residue() && centroid_input_pose_.is_fullatom() ) core::pose::switch_to_residue_type_set(	centroid_input_pose_, chemical::CENTROID );
+	if ( centroid_input_pose_.total_residue() && centroid_input_pose_.is_fullatom() ) protocols::toolbox::switch_to_residue_type_set(	centroid_input_pose_, chemical::CENTROID );
 	//coordinate-cst ---> bExclusive can be switched off.
 }
 
@@ -187,7 +189,7 @@ bool RigidChunkClaimer::read_tag( std::string tag, std::istream& is ) {
 void RigidChunkClaimer::init_after_reading() {
 	tr.Debug << type() << " initialized with input_pdb: " << input_pose_.sequence() << " and regions " << rigid_core_ << std::endl;
 	centroid_input_pose_=input_pose_;
-	if ( centroid_input_pose_.total_residue() && centroid_input_pose_.is_fullatom() ) core::pose::switch_to_residue_type_set(	centroid_input_pose_, chemical::CENTROID );
+	if ( centroid_input_pose_.total_residue() && centroid_input_pose_.is_fullatom() ) protocols::toolbox::switch_to_residue_type_set(	centroid_input_pose_, chemical::CENTROID );
 }
 
 void RigidChunkClaimer::select_parts() {
@@ -243,7 +245,7 @@ void RigidChunkClaimer::new_decoy( core::pose::Pose const& pose ) {
 	if ( bUseInputPose_ ) {
 		input_pose_ = pose;
 		centroid_input_pose_=input_pose_;
-		if ( centroid_input_pose_.total_residue() && centroid_input_pose_.is_fullatom() ) core::pose::switch_to_residue_type_set(	centroid_input_pose_, chemical::CENTROID );
+		if ( centroid_input_pose_.total_residue() && centroid_input_pose_.is_fullatom() ) protocols::toolbox::switch_to_residue_type_set(	centroid_input_pose_, chemical::CENTROID );
 
 		// use loops from ThreadingJob ???
 		if ( bUseThreadingJobLoops_ ) {
diff --git a/src/protocols/topology_broker/TopologyBroker.cc b/src/protocols/topology_broker/TopologyBroker.cc
index c722413..f4a9912 100644
--- a/src/protocols/topology_broker/TopologyBroker.cc
+++ b/src/protocols/topology_broker/TopologyBroker.cc
@@ -88,10 +88,11 @@
 //Auto Headers
 #include <core/chemical/ChemicalManager.fwd.hh>
 #include <core/chemical/VariantType.hh>
-#include <core/pose/util.hh>
 #include <core/id/SequenceMapping.hh>
+#include <core/pose/util.hh>
 #include <protocols/jumping/StrandPairing.hh>
 #include <protocols/moves/MoverContainer.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
 #include <protocols/topology_broker/ClaimerMessage.hh>
 #include <protocols/topology_broker/TopologyClaimer.hh>
 
@@ -754,7 +755,7 @@ void TopologyBroker::switch_to_fullatom( core::pose::Pose& pose ) {
 	tr.Debug << "switch_to_fullatom... " << std::endl;
 
 	if ( !pose.is_fullatom() ) {
-    core::pose::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
+    protocols::toolbox::switch_to_residue_type_set( pose, core::chemical::FA_STANDARD );
 	}
 
 	tr.Debug << "switched to fullatom... " << std::endl;
diff --git a/test/core.test.settings b/test/core.test.settings
index 6bed047..b857058 100644
--- a/test/core.test.settings
+++ b/test/core.test.settings
@@ -76,7 +76,6 @@ sources = {
 		"interaction_graph/SurfaceInteractionGraph",
 		"interaction_graph/HPatchInteractionGraph",
 		"interaction_graph/RotamerDots",
-		"interaction_graph/InteractionGraphFactory",
 		"min_pack",
 		"RotamerTrials",
 		"SymmetricRotamerTrials",
diff --git a/test/core/pack/interaction_graph/InteractionGraphFactory.cxxtest.hh b/test/core/pack/interaction_graph/InteractionGraphFactory.cxxtest.hh
deleted file mode 100644
index fb34178..0000000
--- a/test/core/pack/interaction_graph/InteractionGraphFactory.cxxtest.hh
+++ /dev/null
@@ -1,325 +0,0 @@
-// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
-// vi: set ts=2 noet:
-// :noTabs=false:tabSize=4:indentSize=4:
-//
-// (c) Copyright Rosetta Commons Member Institutions.
-// (c) This file is part of the Rosetta software suite and is made available under license.
-// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
-// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
-// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
-
-/// @file   core/pack/interaction_graph/InteractionGraphFactory.cxxtest.hh
-/// @brief  test for the InteractionGraphFactory
-/// @author Steven Lewis
-
-// Test framework headers
-#include <cxxtest/TestSuite.h>
-#include <test/core/init_util.hh>
-#include <test/util/pose_funcs.hh>
-
-// Core Headers
-#include <core/pack/interaction_graph/DensePDInteractionGraph.hh>
-#include <core/pack/interaction_graph/DoubleLazyInteractionGraph.hh>
-#include <core/pack/interaction_graph/InteractionGraphFactory.hh>
-#include <core/pack/interaction_graph/LazyInteractionGraph.hh>
-#include <core/pack/interaction_graph/LinearMemoryInteractionGraph.hh>
-#include <core/pack/interaction_graph/PDInteractionGraph.hh>
-#include <core/pack/interaction_graph/SurfaceInteractionGraph.hh>
-
-#include <core/pose/Pose.hh>
-#include <core/scoring/ScoreFunction.hh>
-#include <core/scoring/ScoreFunctionFactory.hh>
-#include <core/scoring/ScoreType.hh>
-#include <core/pack/packer_neighbors.hh>
-
-#include <core/pack/task/PackerTask.hh>
-#include <core/pack/task/TaskFactory.hh>
-#include <core/pack/rotamer_set/RotamerSets.hh>
-//#include <core/pack/rotamer_set/RotamerSet.hh>
-
-
-
-//Auto Headers
-#include <core/pose/util.hh>
-
-
-// Utility Headers
-
-// Numeric headers
-
-//using namespace core;
-using namespace core::pack;
-using namespace core::pack::interaction_graph;
-
-// --------------- Test Class --------------- //
-///@details This suite of tests covers the InteractionGraphFactory.  That class's job is to examine the option system/PackerTask and determine the appropriate flavor of InteractionGraph for the packing at hand.  This test creates environments, runs the factory, and uses dynamic_cast to ensure that the created IG is of the correct type.
-class InteractionGraphFactoryTests : public CxxTest::TestSuite {
-
-public:
-
-	bool suite_initialized;
-
-	// Shared data elements go here.
-	core::pose::Pose pose;
-	rotamer_set::RotamerSetsOP rotsets;
-	core::scoring::ScoreFunctionOP scorefxn;
-	core::graph::GraphOP packer_neighbor_graph;
-	task::PackerTaskOP packertask;
-
-
-	// --------------- Suite-level Fixture --------------- //
-
-	InteractionGraphFactoryTests() {
-
-		core_init();
-		pose = create_twores_1ubq_pose();
-
-		// --- ScoreFunction ---
-		// create a score function using the standard packer weights
-		scorefxn = new core::scoring::ScoreFunction();
-		//scorefxn->set_weight( scoring::surface, 0.5 );
-
-
-	}
-
-	virtual ~InteractionGraphFactoryTests() {}
-
-	static InteractionGraphFactoryTests *createSuite() {
-		return new InteractionGraphFactoryTests();
-	}
-
-	static void destroySuite( InteractionGraphFactoryTests *suite ) {
-		delete suite;
-	}
-
-	// --------------- Test Fixture --------------- //
-
-	// Define a test fixture (some initial state that several tests share)
-	// In CxxTest, setUp()/tearDown() are executed around each test case.
-
-	void setUp() {
-	}
-
-	// Shared finalization goes here.
-	void tearDown() {}
-
-	//utility function - we don't care about any of these rotamers but we have to do it anyway for the IGFactory
-	//relies on class member variables instead of passing stuff around
-	void make_rotset(){
-		rotsets = new rotamer_set::RotamerSets();
-		rotsets->set_task( packertask );
-		packer_neighbor_graph = create_packer_graph( pose, *scorefxn, packertask );
-		rotsets->build_rotamers( pose, *scorefxn, packer_neighbor_graph );
-		rotsets->prepare_sets_for_packing( pose, *scorefxn );
-		return;
-	}
-
-
-public:
-
-	// --------------- Test Cases --------------- //
-
-	//As of this writing, we have the following options:
-
-	//If linmem_if is set in the PackerTask
-	//LinearMemoryInteractionGraph
-	//LinearMemorySurfaceInteractionGraph
-	//    if surface weight !=0 and and we are designing
-
-	//else if we are designing, altering >=1 residue, it has >=1 rotamers, and it's not centroid
-	//PDInteractionGraph
-	//PDSurfaceInteractionGraph
-	//    if surface weight !=0, and we are designing
-	//LazyInteractionGraph
-	//    if lazy_ig is set in the PackerTask
-	//DoubleLazyInteractionGraph
-	//    if double_lazy_if is set in the PackerTask
-
-	//else (meaning, no linmem_ig, not designing, in centroid mode, or we have no rotamers)
-	//DensePDInteractionGraph
-
-	/// @detailed we should get a linmemIG if linmem_ig is set in the packer task and surface weight is 0 in the scorefunction
-	void test_LinearMemoryInteractionGraph() {
-		//surface weight 0
-		scorefxn->set_weight( core::scoring::surface, 0 );
-		(*scorefxn)(pose);
-
-		//create packer task, set linmem_ig
-		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
-		packertask->or_linmem_ig(true);
-
-		//create the rotamer sets
-		make_rotset();
-
-		//TEST that the IGFactory returns a linmem_ig
-		TS_ASSERT( dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
-		//let's test a random fail state for kicks
-		TS_ASSERT( !(dynamic_cast<PDInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
-
-		return;
-	}
-
-	///@brief we should get a linmemsurfaceIG if linmem_ig is set in the packer task and surface weight is not 0 in the scorefunction
-	void test_LinearMemorySurfaceInteractionGraph() {
-		//surface weight 1
-		scorefxn->set_weight( core::scoring::surface, 1 );
-		(*scorefxn)(pose);
-
-		//create packer task, set linmem_ig
-		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
-		packertask->or_linmem_ig(true);
-
-		//create the rotamer sets
-		make_rotset();
-
-		//TEST what the IGFactory returns
-		TS_ASSERT( dynamic_cast<LinearMemorySurfaceInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
-		//let's test a random fail state for kicks
-		TS_ASSERT( !(dynamic_cast<PDInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
-
-		return;
-	}
-
-	///@brief we should get this if we are designing, have rotamers, aren't centroid, and surface is nonzero
-	void test_PDSurfaceInteractionGraph() {
-		//surface weight 1
-		scorefxn->set_weight( core::scoring::surface, 1 );
-		(*scorefxn)(pose);
-
-		//create packer task
-		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
-
-		//create the rotamer sets
-		make_rotset();
-
-		//TEST what the IGFactory returns
-		TS_ASSERT( dynamic_cast<PDSurfaceInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
-		//let's test a random fail state for kicks
-		TS_ASSERT( !(dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
-
-		return;
-	}
-
-	///@brief we should get this if we are designing, have rotamers, aren't centroid, and surface is zero
-	void test_PDInteractionGraph() {
-		//surface weight 0
-		scorefxn->set_weight( core::scoring::surface, 0 );
-		(*scorefxn)(pose);
-
-		//create packer task
-		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
-
-		//create the rotamer sets
-		make_rotset();
-
-		//TEST what the IGFactory returns
-		TS_ASSERT( dynamic_cast<PDInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
-		//let's test a random fail state for kicks
-		TS_ASSERT( !(dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
-
-		return;
-	}
-
-	///@brief we should get this if we are designing, have rotamers, aren't centroid, and surface is zero, and lazy_ig is set in the packertask
-	void test_LazyInteractionGraph() {
-		//surface weight 0
-		scorefxn->set_weight( core::scoring::surface, 0 );
-		(*scorefxn)(pose);
-
-		//create packer task
-		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
-		packertask->or_lazy_ig(true);
-
-		//create the rotamer sets
-		make_rotset();
-
-		//TEST what the IGFactory returns
-		TS_ASSERT( dynamic_cast<LazyInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
-		//let's test a random fail state for kicks
-		TS_ASSERT( !(dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
-
-		return;
-	}
-
-	///@brief we should get this if we are designing, have rotamers, aren't centroid, and surface is zero, and double_lazy_ig is set in the packertask
-	void test_DoubleLazyInteractionGraph() {
-		//surface weight 0
-		scorefxn->set_weight( core::scoring::surface, 0 );
-		(*scorefxn)(pose);
-
-		//create packer task
-		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
-		packertask->or_double_lazy_ig(true);
-
-		//create the rotamer sets
-		make_rotset();
-
-		//TEST what the IGFactory returns
-		TS_ASSERT( dynamic_cast<DoubleLazyInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
-		//let's test a random fail state for kicks
-		TS_ASSERT( !(dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
-
-		return;
-	}
-
-	///@brief we should get this if we aren't designing or are centroid, and linmem_ig is not set in the packertask
-	void test_DensePDInteractionGraph() {
-		//TEST 1: not designing
-		//surface weight 0
-		scorefxn->set_weight( core::scoring::surface, 0 );
-		(*scorefxn)(pose);
-
-		//create packer task
-		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
-		packertask->restrict_to_repacking();
-
-		//create the rotamer sets
-		make_rotset();
-
-		//TEST what the IGFactory returns
-		TS_ASSERT( dynamic_cast<DensePDInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
-		//let's test a random fail state for kicks
-		TS_ASSERT( !(dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
-
-
-		//TEST 2: no rotamers
-		//surface weight 0
-		scorefxn->set_weight( core::scoring::surface, 0 );
-		(*scorefxn)(pose);
-
-		//create packer task
-		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
-		for(core::Size i(1), end(packertask->total_residue()); i<=end; ++i)
-			packertask->nonconst_residue_task(i).prevent_repacking();
-
-		//create the rotamer sets
-		make_rotset();
-
-		//TEST what the IGFactory returns
-		TS_ASSERT( dynamic_cast<DensePDInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
-		//let's test a random fail state for kicks
-		TS_ASSERT( !(dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
-
-		//TEST 3: CENTROID!  whoo
-		core::pose::switch_to_residue_type_set(pose, core::chemical::CENTROID);
-
-		//surface weight 0
-		scorefxn->set_weight( core::scoring::surface, 0 );
-		(*scorefxn)(pose);
-
-		//create packer task
-		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
-
-		//create the rotamer sets
-		make_rotset();
-
-		//TEST what the IGFactory returns
-		TS_ASSERT( dynamic_cast<DensePDInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
-		//let's test a random fail state for kicks
-		TS_ASSERT( !(dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
-
-		return;
-	}
-
-};
-
diff --git a/test/protocols.test.settings b/test/protocols.test.settings
index f829d11..df2edb7 100644
--- a/test/protocols.test.settings
+++ b/test/protocols.test.settings
@@ -106,6 +106,9 @@ sources = {
 		"DDGBindOptEData",
 	],
 
+        "pack" : [
+		"interaction_graph/InteractionGraphFactory",
+        ],
         "rotamer_recovery" : [
 		"RRComparer",
                 "RRReporter",
diff --git a/test/protocols/abinitio/PseudocontactShiftEnergy.cxxtest.hh b/test/protocols/abinitio/PseudocontactShiftEnergy.cxxtest.hh
index 6b58abd..ac5e501 100644
--- a/test/protocols/abinitio/PseudocontactShiftEnergy.cxxtest.hh
+++ b/test/protocols/abinitio/PseudocontactShiftEnergy.cxxtest.hh
@@ -55,7 +55,6 @@
 #include <core/scoring/constraints/Constraints.fwd.hh>
 #include <core/scoring/constraints/XYZ_Func.hh>
 #include <core/id/SequenceMapping.hh>
-#include <core/scoring/methods/pcs/GridSearchIterator.fwd.hh>
 #include <core/util/OStream.hh>
 #include <protocols/evaluation/ConstraintEvaluator.hh>
 #include <protocols/jd2/Job.hh>
diff --git a/test/protocols/pack/interaction_graph/InteractionGraphFactory.cxxtest.hh b/test/protocols/pack/interaction_graph/InteractionGraphFactory.cxxtest.hh
new file mode 100644
index 0000000..e5a5e13
--- /dev/null
+++ b/test/protocols/pack/interaction_graph/InteractionGraphFactory.cxxtest.hh
@@ -0,0 +1,326 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+// :noTabs=false:tabSize=4:indentSize=4:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file   core/pack/interaction_graph/InteractionGraphFactory.cxxtest.hh
+/// @brief  test for the InteractionGraphFactory
+/// @author Steven Lewis
+
+// Test framework headers
+#include <cxxtest/TestSuite.h>
+#include <test/core/init_util.hh>
+#include <test/util/pose_funcs.hh>
+
+// Core Headers
+#include <core/pack/interaction_graph/DensePDInteractionGraph.hh>
+#include <core/pack/interaction_graph/DoubleLazyInteractionGraph.hh>
+#include <core/pack/interaction_graph/InteractionGraphFactory.hh>
+#include <core/pack/interaction_graph/LazyInteractionGraph.hh>
+#include <core/pack/interaction_graph/LinearMemoryInteractionGraph.hh>
+#include <core/pack/interaction_graph/PDInteractionGraph.hh>
+#include <core/pack/interaction_graph/SurfaceInteractionGraph.hh>
+
+#include <core/pose/Pose.hh>
+#include <core/scoring/ScoreFunction.hh>
+#include <core/scoring/ScoreFunctionFactory.hh>
+#include <core/scoring/ScoreType.hh>
+#include <core/pack/packer_neighbors.hh>
+
+#include <core/pack/task/PackerTask.hh>
+#include <core/pack/task/TaskFactory.hh>
+#include <core/pack/rotamer_set/RotamerSets.hh>
+//#include <core/pack/rotamer_set/RotamerSet.hh>
+
+
+
+//Auto Headers
+#include <core/pose/util.hh>
+#include <protocols/toolbox/SwitchResidueTypeSet.hh>
+
+
+// Utility Headers
+
+// Numeric headers
+
+//using namespace core;
+using namespace core::pack;
+using namespace core::pack::interaction_graph;
+
+// --------------- Test Class --------------- //
+///@details This suite of tests covers the InteractionGraphFactory.  That class's job is to examine the option system/PackerTask and determine the appropriate flavor of InteractionGraph for the packing at hand.  This test creates environments, runs the factory, and uses dynamic_cast to ensure that the created IG is of the correct type.
+class InteractionGraphFactoryTests : public CxxTest::TestSuite {
+
+public:
+
+	bool suite_initialized;
+
+	// Shared data elements go here.
+	core::pose::Pose pose;
+	rotamer_set::RotamerSetsOP rotsets;
+	core::scoring::ScoreFunctionOP scorefxn;
+	core::graph::GraphOP packer_neighbor_graph;
+	task::PackerTaskOP packertask;
+
+
+	// --------------- Suite-level Fixture --------------- //
+
+	InteractionGraphFactoryTests() {
+
+		core_init();
+		pose = create_twores_1ubq_pose();
+
+		// --- ScoreFunction ---
+		// create a score function using the standard packer weights
+		scorefxn = new core::scoring::ScoreFunction();
+		//scorefxn->set_weight( scoring::surface, 0.5 );
+
+
+	}
+
+	virtual ~InteractionGraphFactoryTests() {}
+
+	static InteractionGraphFactoryTests *createSuite() {
+		return new InteractionGraphFactoryTests();
+	}
+
+	static void destroySuite( InteractionGraphFactoryTests *suite ) {
+		delete suite;
+	}
+
+	// --------------- Test Fixture --------------- //
+
+	// Define a test fixture (some initial state that several tests share)
+	// In CxxTest, setUp()/tearDown() are executed around each test case.
+
+	void setUp() {
+	}
+
+	// Shared finalization goes here.
+	void tearDown() {}
+
+	//utility function - we don't care about any of these rotamers but we have to do it anyway for the IGFactory
+	//relies on class member variables instead of passing stuff around
+	void make_rotset(){
+		rotsets = new rotamer_set::RotamerSets();
+		rotsets->set_task( packertask );
+		packer_neighbor_graph = create_packer_graph( pose, *scorefxn, packertask );
+		rotsets->build_rotamers( pose, *scorefxn, packer_neighbor_graph );
+		rotsets->prepare_sets_for_packing( pose, *scorefxn );
+		return;
+	}
+
+
+public:
+
+	// --------------- Test Cases --------------- //
+
+	//As of this writing, we have the following options:
+
+	//If linmem_if is set in the PackerTask
+	//LinearMemoryInteractionGraph
+	//LinearMemorySurfaceInteractionGraph
+	//    if surface weight !=0 and and we are designing
+
+	//else if we are designing, altering >=1 residue, it has >=1 rotamers, and it's not centroid
+	//PDInteractionGraph
+	//PDSurfaceInteractionGraph
+	//    if surface weight !=0, and we are designing
+	//LazyInteractionGraph
+	//    if lazy_ig is set in the PackerTask
+	//DoubleLazyInteractionGraph
+	//    if double_lazy_if is set in the PackerTask
+
+	//else (meaning, no linmem_ig, not designing, in centroid mode, or we have no rotamers)
+	//DensePDInteractionGraph
+
+	/// @detailed we should get a linmemIG if linmem_ig is set in the packer task and surface weight is 0 in the scorefunction
+	void test_LinearMemoryInteractionGraph() {
+		//surface weight 0
+		scorefxn->set_weight( core::scoring::surface, 0 );
+		(*scorefxn)(pose);
+
+		//create packer task, set linmem_ig
+		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
+		packertask->or_linmem_ig(true);
+
+		//create the rotamer sets
+		make_rotset();
+
+		//TEST that the IGFactory returns a linmem_ig
+		TS_ASSERT( dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
+		//let's test a random fail state for kicks
+		TS_ASSERT( !(dynamic_cast<PDInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
+
+		return;
+	}
+
+	///@brief we should get a linmemsurfaceIG if linmem_ig is set in the packer task and surface weight is not 0 in the scorefunction
+	void test_LinearMemorySurfaceInteractionGraph() {
+		//surface weight 1
+		scorefxn->set_weight( core::scoring::surface, 1 );
+		(*scorefxn)(pose);
+
+		//create packer task, set linmem_ig
+		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
+		packertask->or_linmem_ig(true);
+
+		//create the rotamer sets
+		make_rotset();
+
+		//TEST what the IGFactory returns
+		TS_ASSERT( dynamic_cast<LinearMemorySurfaceInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
+		//let's test a random fail state for kicks
+		TS_ASSERT( !(dynamic_cast<PDInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
+
+		return;
+	}
+
+	///@brief we should get this if we are designing, have rotamers, aren't centroid, and surface is nonzero
+	void test_PDSurfaceInteractionGraph() {
+		//surface weight 1
+		scorefxn->set_weight( core::scoring::surface, 1 );
+		(*scorefxn)(pose);
+
+		//create packer task
+		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
+
+		//create the rotamer sets
+		make_rotset();
+
+		//TEST what the IGFactory returns
+		TS_ASSERT( dynamic_cast<PDSurfaceInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
+		//let's test a random fail state for kicks
+		TS_ASSERT( !(dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
+
+		return;
+	}
+
+	///@brief we should get this if we are designing, have rotamers, aren't centroid, and surface is zero
+	void test_PDInteractionGraph() {
+		//surface weight 0
+		scorefxn->set_weight( core::scoring::surface, 0 );
+		(*scorefxn)(pose);
+
+		//create packer task
+		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
+
+		//create the rotamer sets
+		make_rotset();
+
+		//TEST what the IGFactory returns
+		TS_ASSERT( dynamic_cast<PDInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
+		//let's test a random fail state for kicks
+		TS_ASSERT( !(dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
+
+		return;
+	}
+
+	///@brief we should get this if we are designing, have rotamers, aren't centroid, and surface is zero, and lazy_ig is set in the packertask
+	void test_LazyInteractionGraph() {
+		//surface weight 0
+		scorefxn->set_weight( core::scoring::surface, 0 );
+		(*scorefxn)(pose);
+
+		//create packer task
+		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
+		packertask->or_lazy_ig(true);
+
+		//create the rotamer sets
+		make_rotset();
+
+		//TEST what the IGFactory returns
+		TS_ASSERT( dynamic_cast<LazyInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
+		//let's test a random fail state for kicks
+		TS_ASSERT( !(dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
+
+		return;
+	}
+
+	///@brief we should get this if we are designing, have rotamers, aren't centroid, and surface is zero, and double_lazy_ig is set in the packertask
+	void test_DoubleLazyInteractionGraph() {
+		//surface weight 0
+		scorefxn->set_weight( core::scoring::surface, 0 );
+		(*scorefxn)(pose);
+
+		//create packer task
+		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
+		packertask->or_double_lazy_ig(true);
+
+		//create the rotamer sets
+		make_rotset();
+
+		//TEST what the IGFactory returns
+		TS_ASSERT( dynamic_cast<DoubleLazyInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
+		//let's test a random fail state for kicks
+		TS_ASSERT( !(dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
+
+		return;
+	}
+
+	///@brief we should get this if we aren't designing or are centroid, and linmem_ig is not set in the packertask
+	void test_DensePDInteractionGraph() {
+		//TEST 1: not designing
+		//surface weight 0
+		scorefxn->set_weight( core::scoring::surface, 0 );
+		(*scorefxn)(pose);
+
+		//create packer task
+		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
+		packertask->restrict_to_repacking();
+
+		//create the rotamer sets
+		make_rotset();
+
+		//TEST what the IGFactory returns
+		TS_ASSERT( dynamic_cast<DensePDInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
+		//let's test a random fail state for kicks
+		TS_ASSERT( !(dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
+
+
+		//TEST 2: no rotamers
+		//surface weight 0
+		scorefxn->set_weight( core::scoring::surface, 0 );
+		(*scorefxn)(pose);
+
+		//create packer task
+		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
+		for(core::Size i(1), end(packertask->total_residue()); i<=end; ++i)
+			packertask->nonconst_residue_task(i).prevent_repacking();
+
+		//create the rotamer sets
+		make_rotset();
+
+		//TEST what the IGFactory returns
+		TS_ASSERT( dynamic_cast<DensePDInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
+		//let's test a random fail state for kicks
+		TS_ASSERT( !(dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
+
+		//TEST 3: CENTROID!  whoo
+		protocols::toolbox::switch_to_residue_type_set(pose, core::chemical::CENTROID);
+
+		//surface weight 0
+		scorefxn->set_weight( core::scoring::surface, 0 );
+		(*scorefxn)(pose);
+
+		//create packer task
+		packertask = core::pack::task::TaskFactory::create_packer_task( pose );
+
+		//create the rotamer sets
+		make_rotset();
+
+		//TEST what the IGFactory returns
+		TS_ASSERT( dynamic_cast<DensePDInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) ));
+		//let's test a random fail state for kicks
+		TS_ASSERT( !(dynamic_cast<LinearMemoryInteractionGraph*>( (InteractionGraphFactory::create_interaction_graph( *packertask, *rotsets, pose, *scorefxn )()) )) );
+
+		return;
+	}
+
+};
+
diff --git a/test/utility.test.settings b/test/utility.test.settings
index 2dc2566..a5cb415 100644
--- a/test/utility.test.settings
+++ b/test/utility.test.settings
@@ -64,7 +64,7 @@ sources = {
 }
 include_path = [ "#external/cxxtest", "#" ]
 library_path = []
-libraries    = [ "utility","test", "ObjexxFCL", "z" ]
+libraries    = [ "utility", "ObjexxFCL", "z" ]
 subprojects  = []
 testinputfiles = [
     "io/no_final_newline.txt",
