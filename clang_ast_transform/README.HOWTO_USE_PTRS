The following guide summarizes how to correctly use owning/access pointers;
these are a must once we transition to std:: or boost:: pointers; misuse
will cause compilation errors or run-time crashes (double free). Read it!

Note:
  OP = utility::pointer::owning_ptr AKA std::shared_ptr
  AP = utility::pointer::access_ptr AKA std::weak_ptr
  

Rules:

*) Never put this into an OP
   Only whatever instantiates the object can put that object into an OP.

*) Never put a naked ptr that you received from somewhere into an OP
   Naked pointers can be used and passwed to refer to an object only
   (carefully, there is guarantee that they are valid).

*) Never put a reference into an OP
   You can make a reference from an OP and pass it around but you must
   be careful to ensure that the OP remains alive.

*) If you aren't sure if a pointer will remain valid, use weak_ptrs
   instead of naked pointers and check if they expired or lock() result.

 
Disallowed usage:

*) Creating an OP from this:
     SomeOP someop( this )
  
   Never do this as it will cause double-free crashes. Each object address
   (i.e. resulting from instantiation with new) can be placed into an OP
   exactly once. Putting the same naked pointer into a second OP will result
   in a double-freeing of the object and hence a seg fault.
   
   Suggested use:
   SomeOP someop( new Some( ... ) )
   

*) Assigning a naked pointer to an OP:
     Some o = new Some;
     SomeOP op1 = new Some;
     SomeOP op2 = o;
   
   Will not compile. This is explicitly disallowed so the developers have to
   explicitly indicate that they want the OP to manage the lifetime of the
   provided naked pointer. Do this, and only once for a given instance:
     SomeOP op( new Some );


*) Passing or assigning this to an AP:
     SomeCAP somecap( this );
     foo( this );
     
   Will not compile. An AP can only be created from an OP. Classes that need
   to pass a pointer to self (to an AP or OP) need to implement this_weak_ptr_
   and set_weak_pointer_to_self(); any code that instantiates this class
   needs to immediately call set_weak_pointer_to_self() on it.
   See: ResidueType.
   
   Alternatively, make the constructor of the class private and provide a
   static method to instantiate and set the weak pointer reference right
   after instantiation -- preferred approach:
   
   class X {
   private:
     X( ... ) : this_weak_ptr_() {
       ...
     }
   public:
     inline static XOP newX( ... ) {
       XOP op( new X( ... ) );
       op->this_weak_ptr_ = XAP( op );
       return op;
     }
   private:
     XAP this_weak_ptr_;
   };
   
   This is also why this won't compile:
     SomeCAP somecap( 0 );
   Simply use:
     SomeCAP somecap;
     
   The default constructor initialized the AP with null.
   
   
*) Dereferencing an AP directly:
     some_ap_->foo()
     some_ap_->var
   
   Disallowed. Will not compile. One must lock() the AP first:
     some_ap_.lock()->foo()
     some_ap_.lock()->var
   
   Note: When locking fails, the above will result in a null pointer
   dereference and seg fault. If unsure if locking will succeed, assign to
   an OP first:
     SomeOP some_op = some_ap_.lock();
     if(some_op) {
       some_op->foo();
     } 
   
   An AP can be checked for validity with some_ap_.expired(), however,
   there is no guarantee that an AP will not expire between checking and
   locking. Use lock() and check the result instead if an AP is expected
   to be not always valid.
   
   If an AP should always be valid, one can create an OP from AP directly:
     SomeOP some_op( some_ap_ );
     
   This throw a bad_weak_ptr exception if AP expired, which helps with
   troubleshooting and can be caught.
   
   Using lock() without checking the result is fast but dangerous.
   
   
*) Comparing an AP with an AP, OP, naked pointer or this:
     if( some_ap == this )
     if( some_ap == some_other_ap )
     if( some_ap == some_op)
     if( some_ap == &some_ref )

   Not allowed, will not compile. Use equal helper template instead:
     utility::pointer::equal( some_ap, this )
     utility::pointer::equal( some_ap, some_other_ap )
     utility::pointer::equal( some_ap, some_op )
     utility::pointer::equal( some_ap, &ref )
     
   See also: 
   http://stackoverflow.com/questions/12301916/equality-compare-stdweak-ptr


*) Creating a set of AP:
     typedef std::set< SomeCAP > SomeSet;
     
   Will not compile. Because a set is ordered but weak_ptr cannot be compared,
   we need to provide a comparator in C++11:
     typedef std::set< SomeCAP, std::owner_less< SomeCAP > > SomeSet;


*) Create an OP from a reference:
     SomeOP someop( &someref );
   This will cause double-free crashes. Never create an OP from a reference.
   Just don't. This is totally illegal but will compile ... and crash:
     SomeOP op( new Some );
     Some &op_ref = *op;
     SomeOP op2( &op_ref );
     
   These are OK:
     SomeOP op( new Some );
     SomeAP ap( op );
     SomeOP op2( op );
     SomeOP op3( ap );
     SomeAP ap2( ap );


